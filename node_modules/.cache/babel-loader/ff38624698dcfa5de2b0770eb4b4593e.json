{"ast":null,"code":"import * as React from 'react';\nexport default function useResizable(items, pxSizes, isRTL) {\n  return React.useMemo(function () {\n    var resizeInfos = [];\n\n    for (var i = 0; i < items.length - 1; i += 1) {\n      var prevItem = items[i];\n      var nextItem = items[i + 1];\n      var prevSize = pxSizes[i];\n      var nextSize = pxSizes[i + 1];\n      var _prevItem$resizable = prevItem.resizable,\n          prevResizable = _prevItem$resizable === void 0 ? true : _prevItem$resizable,\n          prevMin = prevItem.min,\n          prevCollapsible = prevItem.collapsible;\n      var _nextItem$resizable = nextItem.resizable,\n          nextResizable = _nextItem$resizable === void 0 ? true : _nextItem$resizable,\n          nextMin = nextItem.min,\n          nextCollapsible = nextItem.collapsible;\n      var mergedResizable = // Both need to be resizable\n      prevResizable && nextResizable && ( // Prev is not collapsed and limit min size\n      prevSize !== 0 || !prevMin) && ( // Next is not collapsed and limit min size\n      nextSize !== 0 || !nextMin);\n      var startCollapsible = // Self is collapsible\n      prevCollapsible.end && prevSize > 0 || // Collapsed and can be collapsed\n      nextCollapsible.start && nextSize === 0 && prevSize > 0;\n      var endCollapsible = // Self is collapsible\n      nextCollapsible.start && nextSize > 0 || // Collapsed and can be collapsed\n      prevCollapsible.end && prevSize === 0 && nextSize > 0;\n      resizeInfos[i] = {\n        resizable: mergedResizable,\n        startCollapsible: !!(isRTL ? endCollapsible : startCollapsible),\n        endCollapsible: !!(isRTL ? startCollapsible : endCollapsible)\n      };\n    }\n\n    return resizeInfos;\n  }, [pxSizes, items]);\n}","map":{"version":3,"sources":["/Users/shamryshiraz/Documents/New/Untitled/Portfolio/New/Portfolio-Ruwan-Prasanna/node_modules/antd/es/splitter/hooks/useResizable.js"],"names":["React","useResizable","items","pxSizes","isRTL","useMemo","resizeInfos","i","length","prevItem","nextItem","prevSize","nextSize","resizable","prevResizable","prevMin","min","prevCollapsible","collapsible","nextResizable","nextMin","nextCollapsible","mergedResizable","startCollapsible","end","start","endCollapsible"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,eAAe,SAASC,YAAT,CAAsBC,KAAtB,EAA6BC,OAA7B,EAAsCC,KAAtC,EAA6C;AAC1D,SAAOJ,KAAK,CAACK,OAAN,CAAc,YAAM;AACzB,QAAMC,WAAW,GAAG,EAApB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAAK,CAACM,MAAN,GAAe,CAAnC,EAAsCD,CAAC,IAAI,CAA3C,EAA8C;AAC5C,UAAME,QAAQ,GAAGP,KAAK,CAACK,CAAD,CAAtB;AACA,UAAMG,QAAQ,GAAGR,KAAK,CAACK,CAAC,GAAG,CAAL,CAAtB;AACA,UAAMI,QAAQ,GAAGR,OAAO,CAACI,CAAD,CAAxB;AACA,UAAMK,QAAQ,GAAGT,OAAO,CAACI,CAAC,GAAG,CAAL,CAAxB;AACA,gCAIIE,QAJJ,CACEI,SADF;AAAA,UACaC,aADb,oCAC6B,IAD7B;AAAA,UAEOC,OAFP,GAIIN,QAJJ,CAEEO,GAFF;AAAA,UAGeC,eAHf,GAIIR,QAJJ,CAGES,WAHF;AAKA,gCAIIR,QAJJ,CACEG,SADF;AAAA,UACaM,aADb,oCAC6B,IAD7B;AAAA,UAEOC,OAFP,GAIIV,QAJJ,CAEEM,GAFF;AAAA,UAGeK,eAHf,GAIIX,QAJJ,CAGEQ,WAHF;AAKA,UAAMI,eAAe,GACrB;AACAR,MAAAA,aAAa,IAAIK,aAAjB,MACA;AACAR,MAAAA,QAAQ,KAAK,CAAb,IAAkB,CAACI,OAFnB,OAGA;AACAH,MAAAA,QAAQ,KAAK,CAAb,IAAkB,CAACQ,OAJnB,CAFA;AAOA,UAAMG,gBAAgB,GACtB;AACAN,MAAAA,eAAe,CAACO,GAAhB,IAAuBb,QAAQ,GAAG,CAAlC,IACA;AACAU,MAAAA,eAAe,CAACI,KAAhB,IAAyBb,QAAQ,KAAK,CAAtC,IAA2CD,QAAQ,GAAG,CAJtD;AAKA,UAAMe,cAAc,GACpB;AACAL,MAAAA,eAAe,CAACI,KAAhB,IAAyBb,QAAQ,GAAG,CAApC,IACA;AACAK,MAAAA,eAAe,CAACO,GAAhB,IAAuBb,QAAQ,KAAK,CAApC,IAAyCC,QAAQ,GAAG,CAJpD;AAKAN,MAAAA,WAAW,CAACC,CAAD,CAAX,GAAiB;AACfM,QAAAA,SAAS,EAAES,eADI;AAEfC,QAAAA,gBAAgB,EAAE,CAAC,EAAEnB,KAAK,GAAGsB,cAAH,GAAoBH,gBAA3B,CAFJ;AAGfG,QAAAA,cAAc,EAAE,CAAC,EAAEtB,KAAK,GAAGmB,gBAAH,GAAsBG,cAA7B;AAHF,OAAjB;AAKD;;AACD,WAAOpB,WAAP;AACD,GAzCM,EAyCJ,CAACH,OAAD,EAAUD,KAAV,CAzCI,CAAP;AA0CD","sourcesContent":["import * as React from 'react';\nexport default function useResizable(items, pxSizes, isRTL) {\n  return React.useMemo(() => {\n    const resizeInfos = [];\n    for (let i = 0; i < items.length - 1; i += 1) {\n      const prevItem = items[i];\n      const nextItem = items[i + 1];\n      const prevSize = pxSizes[i];\n      const nextSize = pxSizes[i + 1];\n      const {\n        resizable: prevResizable = true,\n        min: prevMin,\n        collapsible: prevCollapsible\n      } = prevItem;\n      const {\n        resizable: nextResizable = true,\n        min: nextMin,\n        collapsible: nextCollapsible\n      } = nextItem;\n      const mergedResizable =\n      // Both need to be resizable\n      prevResizable && nextResizable && (\n      // Prev is not collapsed and limit min size\n      prevSize !== 0 || !prevMin) && (\n      // Next is not collapsed and limit min size\n      nextSize !== 0 || !nextMin);\n      const startCollapsible =\n      // Self is collapsible\n      prevCollapsible.end && prevSize > 0 ||\n      // Collapsed and can be collapsed\n      nextCollapsible.start && nextSize === 0 && prevSize > 0;\n      const endCollapsible =\n      // Self is collapsible\n      nextCollapsible.start && nextSize > 0 ||\n      // Collapsed and can be collapsed\n      prevCollapsible.end && prevSize === 0 && nextSize > 0;\n      resizeInfos[i] = {\n        resizable: mergedResizable,\n        startCollapsible: !!(isRTL ? endCollapsible : startCollapsible),\n        endCollapsible: !!(isRTL ? startCollapsible : endCollapsible)\n      };\n    }\n    return resizeInfos;\n  }, [pxSizes, items]);\n}"]},"metadata":{},"sourceType":"module"}