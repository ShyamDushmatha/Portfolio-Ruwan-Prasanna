{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport { Color as RcColor } from '@rc-component/color-picker';\nimport { AggregationColor } from './color';\nexport var generateColor = function generateColor(color) {\n  if (color instanceof AggregationColor) {\n    return color;\n  }\n\n  return new AggregationColor(color);\n};\nexport var getRoundNumber = function getRoundNumber(value) {\n  return Math.round(Number(value || 0));\n};\nexport var getColorAlpha = function getColorAlpha(color) {\n  return getRoundNumber(color.toHsb().a * 100);\n};\n/** Return the color whose `alpha` is 1 */\n\nexport var genAlphaColor = function genAlphaColor(color, alpha) {\n  var rgba = color.toRgb(); // Color from hsb input may get `rgb` is (0/0/0) when `hsb.b` is 0\n  // So if rgb is empty, we should get from hsb\n\n  if (!rgba.r && !rgba.g && !rgba.b) {\n    var hsba = color.toHsb();\n    hsba.a = alpha || 1;\n    return generateColor(hsba);\n  }\n\n  rgba.a = alpha || 1;\n  return generateColor(rgba);\n};\n/**\n * Get percent position color. e.g. [10%-#fff, 20%-#000], 15% => #888\n */\n\nexport var getGradientPercentColor = function getGradientPercentColor(colors, percent) {\n  var filledColors = [{\n    percent: 0,\n    color: colors[0].color\n  }].concat(_toConsumableArray(colors), [{\n    percent: 100,\n    color: colors[colors.length - 1].color\n  }]);\n\n  for (var i = 0; i < filledColors.length - 1; i += 1) {\n    var startPtg = filledColors[i].percent;\n    var endPtg = filledColors[i + 1].percent;\n    var startColor = filledColors[i].color;\n    var endColor = filledColors[i + 1].color;\n\n    if (startPtg <= percent && percent <= endPtg) {\n      var dist = endPtg - startPtg;\n\n      if (dist === 0) {\n        return startColor;\n      }\n\n      var ratio = (percent - startPtg) / dist * 100;\n      var startRcColor = new RcColor(startColor);\n      var endRcColor = new RcColor(endColor);\n      return startRcColor.mix(endRcColor, ratio).toRgbString();\n    }\n  } // This will never reach\n\n  /* istanbul ignore next */\n\n\n  return '';\n};","map":{"version":3,"sources":["/Users/shamryshiraz/Documents/New/Untitled/Portfolio/node_modules/antd/es/color-picker/util.js"],"names":["_toConsumableArray","Color","RcColor","AggregationColor","generateColor","color","getRoundNumber","value","Math","round","Number","getColorAlpha","toHsb","a","genAlphaColor","alpha","rgba","toRgb","r","g","b","hsba","getGradientPercentColor","colors","percent","filledColors","concat","length","i","startPtg","endPtg","startColor","endColor","dist","ratio","startRcColor","endRcColor","mix","toRgbString"],"mappings":"AAAA,OAAOA,kBAAP,MAA+B,8CAA/B;AACA,SAASC,KAAK,IAAIC,OAAlB,QAAiC,4BAAjC;AACA,SAASC,gBAAT,QAAiC,SAAjC;AACA,OAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAAAC,KAAK,EAAI;AACpC,MAAIA,KAAK,YAAYF,gBAArB,EAAuC;AACrC,WAAOE,KAAP;AACD;;AACD,SAAO,IAAIF,gBAAJ,CAAqBE,KAArB,CAAP;AACD,CALM;AAMP,OAAO,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAAAC,KAAK;AAAA,SAAIC,IAAI,CAACC,KAAL,CAAWC,MAAM,CAACH,KAAK,IAAI,CAAV,CAAjB,CAAJ;AAAA,CAA5B;AACP,OAAO,IAAMI,aAAa,GAAG,SAAhBA,aAAgB,CAAAN,KAAK;AAAA,SAAIC,cAAc,CAACD,KAAK,CAACO,KAAN,GAAcC,CAAd,GAAkB,GAAnB,CAAlB;AAAA,CAA3B;AACP;;AACA,OAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACT,KAAD,EAAQU,KAAR,EAAkB;AAC7C,MAAMC,IAAI,GAAGX,KAAK,CAACY,KAAN,EAAb,CAD6C,CAE7C;AACA;;AACA,MAAI,CAACD,IAAI,CAACE,CAAN,IAAW,CAACF,IAAI,CAACG,CAAjB,IAAsB,CAACH,IAAI,CAACI,CAAhC,EAAmC;AACjC,QAAMC,IAAI,GAAGhB,KAAK,CAACO,KAAN,EAAb;AACAS,IAAAA,IAAI,CAACR,CAAL,GAASE,KAAK,IAAI,CAAlB;AACA,WAAOX,aAAa,CAACiB,IAAD,CAApB;AACD;;AACDL,EAAAA,IAAI,CAACH,CAAL,GAASE,KAAK,IAAI,CAAlB;AACA,SAAOX,aAAa,CAACY,IAAD,CAApB;AACD,CAXM;AAYP;AACA;AACA;;AACA,OAAO,IAAMM,uBAAuB,GAAG,SAA1BA,uBAA0B,CAACC,MAAD,EAASC,OAAT,EAAqB;AAC1D,MAAMC,YAAY,GAAG,CAAC;AACpBD,IAAAA,OAAO,EAAE,CADW;AAEpBnB,IAAAA,KAAK,EAAEkB,MAAM,CAAC,CAAD,CAAN,CAAUlB;AAFG,GAAD,EAGlBqB,MAHkB,CAGX1B,kBAAkB,CAACuB,MAAD,CAHP,EAGiB,CAAC;AACrCC,IAAAA,OAAO,EAAE,GAD4B;AAErCnB,IAAAA,KAAK,EAAEkB,MAAM,CAACA,MAAM,CAACI,MAAP,GAAgB,CAAjB,CAAN,CAA0BtB;AAFI,GAAD,CAHjB,CAArB;;AAOA,OAAK,IAAIuB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,YAAY,CAACE,MAAb,GAAsB,CAA1C,EAA6CC,CAAC,IAAI,CAAlD,EAAqD;AACnD,QAAMC,QAAQ,GAAGJ,YAAY,CAACG,CAAD,CAAZ,CAAgBJ,OAAjC;AACA,QAAMM,MAAM,GAAGL,YAAY,CAACG,CAAC,GAAG,CAAL,CAAZ,CAAoBJ,OAAnC;AACA,QAAMO,UAAU,GAAGN,YAAY,CAACG,CAAD,CAAZ,CAAgBvB,KAAnC;AACA,QAAM2B,QAAQ,GAAGP,YAAY,CAACG,CAAC,GAAG,CAAL,CAAZ,CAAoBvB,KAArC;;AACA,QAAIwB,QAAQ,IAAIL,OAAZ,IAAuBA,OAAO,IAAIM,MAAtC,EAA8C;AAC5C,UAAMG,IAAI,GAAGH,MAAM,GAAGD,QAAtB;;AACA,UAAII,IAAI,KAAK,CAAb,EAAgB;AACd,eAAOF,UAAP;AACD;;AACD,UAAMG,KAAK,GAAG,CAACV,OAAO,GAAGK,QAAX,IAAuBI,IAAvB,GAA8B,GAA5C;AACA,UAAME,YAAY,GAAG,IAAIjC,OAAJ,CAAY6B,UAAZ,CAArB;AACA,UAAMK,UAAU,GAAG,IAAIlC,OAAJ,CAAY8B,QAAZ,CAAnB;AACA,aAAOG,YAAY,CAACE,GAAb,CAAiBD,UAAjB,EAA6BF,KAA7B,EAAoCI,WAApC,EAAP;AACD;AACF,GAvByD,CAwB1D;;AACA;;;AACA,SAAO,EAAP;AACD,CA3BM","sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport { Color as RcColor } from '@rc-component/color-picker';\nimport { AggregationColor } from './color';\nexport const generateColor = color => {\n  if (color instanceof AggregationColor) {\n    return color;\n  }\n  return new AggregationColor(color);\n};\nexport const getRoundNumber = value => Math.round(Number(value || 0));\nexport const getColorAlpha = color => getRoundNumber(color.toHsb().a * 100);\n/** Return the color whose `alpha` is 1 */\nexport const genAlphaColor = (color, alpha) => {\n  const rgba = color.toRgb();\n  // Color from hsb input may get `rgb` is (0/0/0) when `hsb.b` is 0\n  // So if rgb is empty, we should get from hsb\n  if (!rgba.r && !rgba.g && !rgba.b) {\n    const hsba = color.toHsb();\n    hsba.a = alpha || 1;\n    return generateColor(hsba);\n  }\n  rgba.a = alpha || 1;\n  return generateColor(rgba);\n};\n/**\n * Get percent position color. e.g. [10%-#fff, 20%-#000], 15% => #888\n */\nexport const getGradientPercentColor = (colors, percent) => {\n  const filledColors = [{\n    percent: 0,\n    color: colors[0].color\n  }].concat(_toConsumableArray(colors), [{\n    percent: 100,\n    color: colors[colors.length - 1].color\n  }]);\n  for (let i = 0; i < filledColors.length - 1; i += 1) {\n    const startPtg = filledColors[i].percent;\n    const endPtg = filledColors[i + 1].percent;\n    const startColor = filledColors[i].color;\n    const endColor = filledColors[i + 1].color;\n    if (startPtg <= percent && percent <= endPtg) {\n      const dist = endPtg - startPtg;\n      if (dist === 0) {\n        return startColor;\n      }\n      const ratio = (percent - startPtg) / dist * 100;\n      const startRcColor = new RcColor(startColor);\n      const endRcColor = new RcColor(endColor);\n      return startRcColor.mix(endRcColor, ratio).toRgbString();\n    }\n  }\n  // This will never reach\n  /* istanbul ignore next */\n  return '';\n};"]},"metadata":{},"sourceType":"module"}