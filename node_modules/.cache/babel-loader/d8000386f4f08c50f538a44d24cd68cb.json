{"ast":null,"code":"import _slicedToArray from \"/Users/shamryshiraz/Documents/New/Untitled/Portfolio/New/Portfolio-Ruwan-Prasanna/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport React from 'react';\nimport toList from '../_util/toList';\nexport var FontGap = 3;\n\nvar prepareCanvas = function prepareCanvas(width, height) {\n  var ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var canvas = document.createElement('canvas');\n  var ctx = canvas.getContext('2d');\n  var realWidth = width * ratio;\n  var realHeight = height * ratio;\n  canvas.setAttribute('width', \"\".concat(realWidth, \"px\"));\n  canvas.setAttribute('height', \"\".concat(realHeight, \"px\"));\n  ctx.save();\n  return [ctx, canvas, realWidth, realHeight];\n}; // Get boundary of rotated text\n\n\nvar getRotatePos = function getRotatePos(x, y, angle) {\n  var targetX = x * Math.cos(angle) - y * Math.sin(angle);\n  var targetY = x * Math.sin(angle) + y * Math.cos(angle);\n  return [targetX, targetY];\n};\n/**\n * Get the clips of text content.\n * This is a lazy hook function since SSR no need this\n */\n\n\nvar useClips = function useClips() {\n  // Get single clips\n  var getClips = function getClips(content, rotate, ratio, width, height, font, gapX, gapY) {\n    // ================= Text / Image =================\n    var _prepareCanvas = prepareCanvas(width, height, ratio),\n        _prepareCanvas2 = _slicedToArray(_prepareCanvas, 4),\n        ctx = _prepareCanvas2[0],\n        canvas = _prepareCanvas2[1],\n        contentWidth = _prepareCanvas2[2],\n        contentHeight = _prepareCanvas2[3];\n\n    if (content instanceof HTMLImageElement) {\n      // Image\n      ctx.drawImage(content, 0, 0, contentWidth, contentHeight);\n    } else {\n      // Text\n      var color = font.color,\n          fontSize = font.fontSize,\n          fontStyle = font.fontStyle,\n          fontWeight = font.fontWeight,\n          fontFamily = font.fontFamily,\n          textAlign = font.textAlign;\n      var mergedFontSize = Number(fontSize) * ratio;\n      ctx.font = \"\".concat(fontStyle, \" normal \").concat(fontWeight, \" \").concat(mergedFontSize, \"px/\").concat(height, \"px \").concat(fontFamily);\n      ctx.fillStyle = color;\n      ctx.textAlign = textAlign;\n      ctx.textBaseline = 'top';\n      var contents = toList(content);\n      contents === null || contents === void 0 ? void 0 : contents.forEach(function (item, index) {\n        ctx.fillText(item !== null && item !== void 0 ? item : '', contentWidth / 2, index * (mergedFontSize + FontGap * ratio));\n      });\n    } // ==================== Rotate ====================\n\n\n    var angle = Math.PI / 180 * Number(rotate);\n    var maxSize = Math.max(width, height);\n\n    var _prepareCanvas3 = prepareCanvas(maxSize, maxSize, ratio),\n        _prepareCanvas4 = _slicedToArray(_prepareCanvas3, 3),\n        rCtx = _prepareCanvas4[0],\n        rCanvas = _prepareCanvas4[1],\n        realMaxSize = _prepareCanvas4[2]; // Copy from `ctx` and rotate\n\n\n    rCtx.translate(realMaxSize / 2, realMaxSize / 2);\n    rCtx.rotate(angle);\n\n    if (contentWidth > 0 && contentHeight > 0) {\n      rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);\n    }\n\n    var left = 0;\n    var right = 0;\n    var top = 0;\n    var bottom = 0;\n    var halfWidth = contentWidth / 2;\n    var halfHeight = contentHeight / 2;\n    var points = [[0 - halfWidth, 0 - halfHeight], [0 + halfWidth, 0 - halfHeight], [0 + halfWidth, 0 + halfHeight], [0 - halfWidth, 0 + halfHeight]];\n    points.forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n\n      var _getRotatePos = getRotatePos(x, y, angle),\n          _getRotatePos2 = _slicedToArray(_getRotatePos, 2),\n          targetX = _getRotatePos2[0],\n          targetY = _getRotatePos2[1];\n\n      left = Math.min(left, targetX);\n      right = Math.max(right, targetX);\n      top = Math.min(top, targetY);\n      bottom = Math.max(bottom, targetY);\n    });\n    var cutLeft = left + realMaxSize / 2;\n    var cutTop = top + realMaxSize / 2;\n    var cutWidth = right - left;\n    var cutHeight = bottom - top; // ================ Fill Alternate ================\n\n    var realGapX = gapX * ratio;\n    var realGapY = gapY * ratio;\n    var filledWidth = (cutWidth + realGapX) * 2;\n    var filledHeight = cutHeight + realGapY;\n\n    var _prepareCanvas5 = prepareCanvas(filledWidth, filledHeight),\n        _prepareCanvas6 = _slicedToArray(_prepareCanvas5, 2),\n        fCtx = _prepareCanvas6[0],\n        fCanvas = _prepareCanvas6[1];\n\n    var drawImg = function drawImg() {\n      var targetX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var targetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      fCtx.drawImage(rCanvas, cutLeft, cutTop, cutWidth, cutHeight, targetX, targetY, cutWidth, cutHeight);\n    };\n\n    drawImg();\n    drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);\n    drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);\n    return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];\n  };\n\n  return React.useCallback(getClips, []);\n};\n\nexport default useClips;","map":{"version":3,"sources":["/Users/shamryshiraz/Documents/New/Untitled/Portfolio/New/Portfolio-Ruwan-Prasanna/node_modules/antd/es/watermark/useClips.js"],"names":["React","toList","FontGap","prepareCanvas","width","height","ratio","canvas","document","createElement","ctx","getContext","realWidth","realHeight","setAttribute","save","getRotatePos","x","y","angle","targetX","Math","cos","sin","targetY","useClips","getClips","content","rotate","font","gapX","gapY","contentWidth","contentHeight","HTMLImageElement","drawImage","color","fontSize","fontStyle","fontWeight","fontFamily","textAlign","mergedFontSize","Number","fillStyle","textBaseline","contents","forEach","item","index","fillText","PI","maxSize","max","rCtx","rCanvas","realMaxSize","translate","left","right","top","bottom","halfWidth","halfHeight","points","min","cutLeft","cutTop","cutWidth","cutHeight","realGapX","realGapY","filledWidth","filledHeight","fCtx","fCanvas","drawImg","toDataURL","useCallback"],"mappings":"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","sourcesContent":["import React from 'react';\nimport toList from '../_util/toList';\nexport const FontGap = 3;\nconst prepareCanvas = (width, height, ratio = 1) => {\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  const realWidth = width * ratio;\n  const realHeight = height * ratio;\n  canvas.setAttribute('width', `${realWidth}px`);\n  canvas.setAttribute('height', `${realHeight}px`);\n  ctx.save();\n  return [ctx, canvas, realWidth, realHeight];\n};\n// Get boundary of rotated text\nconst getRotatePos = (x, y, angle) => {\n  const targetX = x * Math.cos(angle) - y * Math.sin(angle);\n  const targetY = x * Math.sin(angle) + y * Math.cos(angle);\n  return [targetX, targetY];\n};\n/**\n * Get the clips of text content.\n * This is a lazy hook function since SSR no need this\n */\nconst useClips = () => {\n  // Get single clips\n  const getClips = (content, rotate, ratio, width, height, font, gapX, gapY) => {\n    // ================= Text / Image =================\n    const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(width, height, ratio);\n    if (content instanceof HTMLImageElement) {\n      // Image\n      ctx.drawImage(content, 0, 0, contentWidth, contentHeight);\n    } else {\n      // Text\n      const {\n        color,\n        fontSize,\n        fontStyle,\n        fontWeight,\n        fontFamily,\n        textAlign\n      } = font;\n      const mergedFontSize = Number(fontSize) * ratio;\n      ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;\n      ctx.fillStyle = color;\n      ctx.textAlign = textAlign;\n      ctx.textBaseline = 'top';\n      const contents = toList(content);\n      contents === null || contents === void 0 ? void 0 : contents.forEach((item, index) => {\n        ctx.fillText(item !== null && item !== void 0 ? item : '', contentWidth / 2, index * (mergedFontSize + FontGap * ratio));\n      });\n    }\n    // ==================== Rotate ====================\n    const angle = Math.PI / 180 * Number(rotate);\n    const maxSize = Math.max(width, height);\n    const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio);\n    // Copy from `ctx` and rotate\n    rCtx.translate(realMaxSize / 2, realMaxSize / 2);\n    rCtx.rotate(angle);\n    if (contentWidth > 0 && contentHeight > 0) {\n      rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);\n    }\n    let left = 0;\n    let right = 0;\n    let top = 0;\n    let bottom = 0;\n    const halfWidth = contentWidth / 2;\n    const halfHeight = contentHeight / 2;\n    const points = [[0 - halfWidth, 0 - halfHeight], [0 + halfWidth, 0 - halfHeight], [0 + halfWidth, 0 + halfHeight], [0 - halfWidth, 0 + halfHeight]];\n    points.forEach(([x, y]) => {\n      const [targetX, targetY] = getRotatePos(x, y, angle);\n      left = Math.min(left, targetX);\n      right = Math.max(right, targetX);\n      top = Math.min(top, targetY);\n      bottom = Math.max(bottom, targetY);\n    });\n    const cutLeft = left + realMaxSize / 2;\n    const cutTop = top + realMaxSize / 2;\n    const cutWidth = right - left;\n    const cutHeight = bottom - top;\n    // ================ Fill Alternate ================\n    const realGapX = gapX * ratio;\n    const realGapY = gapY * ratio;\n    const filledWidth = (cutWidth + realGapX) * 2;\n    const filledHeight = cutHeight + realGapY;\n    const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);\n    const drawImg = (targetX = 0, targetY = 0) => {\n      fCtx.drawImage(rCanvas, cutLeft, cutTop, cutWidth, cutHeight, targetX, targetY, cutWidth, cutHeight);\n    };\n    drawImg();\n    drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);\n    drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);\n    return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];\n  };\n  return React.useCallback(getClips, []);\n};\nexport default useClips;"]},"metadata":{},"sourceType":"module"}