{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { isDOM } from \"rc-util/es/Dom/findDOMNode\";\nimport isVisible from \"rc-util/es/Dom/isVisible\";\nimport useEvent from \"rc-util/es/hooks/useEvent\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport { collectScroller, getVisibleArea, getWin, toNum } from \"../util\";\n\nfunction getUnitOffset(size) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var offsetStr = \"\".concat(offset);\n  var cells = offsetStr.match(/^(.*)\\%$/);\n\n  if (cells) {\n    return size * (parseFloat(cells[1]) / 100);\n  }\n\n  return parseFloat(offsetStr);\n}\n\nfunction getNumberOffset(rect, offset) {\n  var _ref = offset || [],\n      _ref2 = _slicedToArray(_ref, 2),\n      offsetX = _ref2[0],\n      offsetY = _ref2[1];\n\n  return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];\n}\n\nfunction splitPoints() {\n  var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return [points[0], points[1]];\n}\n\nfunction getAlignPoint(rect, points) {\n  var topBottom = points[0];\n  var leftRight = points[1];\n  var x;\n  var y; // Top & Bottom\n\n  if (topBottom === 't') {\n    y = rect.y;\n  } else if (topBottom === 'b') {\n    y = rect.y + rect.height;\n  } else {\n    y = rect.y + rect.height / 2;\n  } // Left & Right\n\n\n  if (leftRight === 'l') {\n    x = rect.x;\n  } else if (leftRight === 'r') {\n    x = rect.x + rect.width;\n  } else {\n    x = rect.x + rect.width / 2;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}\n\nfunction reversePoints(points, index) {\n  var reverseMap = {\n    t: 'b',\n    b: 't',\n    l: 'r',\n    r: 'l'\n  };\n  return points.map(function (point, i) {\n    if (i === index) {\n      return reverseMap[point] || 'c';\n    }\n\n    return point;\n  }).join('');\n}\n\nexport default function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {\n  var _React$useState = React.useState({\n    ready: false,\n    offsetX: 0,\n    offsetY: 0,\n    offsetR: 0,\n    offsetB: 0,\n    arrowX: 0,\n    arrowY: 0,\n    scaleX: 1,\n    scaleY: 1,\n    align: builtinPlacements[placement] || {}\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      offsetInfo = _React$useState2[0],\n      setOffsetInfo = _React$useState2[1];\n\n  var alignCountRef = React.useRef(0);\n  var scrollerList = React.useMemo(function () {\n    if (!popupEle) {\n      return [];\n    }\n\n    return collectScroller(popupEle);\n  }, [popupEle]); // ========================= Flip ==========================\n  // We will memo flip info.\n  // If size change to make flip, it will memo the flip info and use it in next align.\n\n  var prevFlipRef = React.useRef({});\n\n  var resetFlipCache = function resetFlipCache() {\n    prevFlipRef.current = {};\n  };\n\n  if (!open) {\n    resetFlipCache();\n  } // ========================= Align =========================\n\n\n  var onAlign = useEvent(function () {\n    if (popupEle && target && open) {\n      // ============== Intersection ===============\n      // Get area by position. Used for check if flip area is better\n      var getIntersectionVisibleArea = function getIntersectionVisibleArea(offsetX, offsetY) {\n        var area = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : visibleArea;\n        var l = popupRect.x + offsetX;\n        var t = popupRect.y + offsetY;\n        var r = l + popupWidth;\n        var b = t + popupHeight;\n        var visibleL = Math.max(l, area.left);\n        var visibleT = Math.max(t, area.top);\n        var visibleR = Math.min(r, area.right);\n        var visibleB = Math.min(b, area.bottom);\n        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));\n      };\n\n      var syncNextPopupPosition = function syncNextPopupPosition() {\n        nextPopupY = popupRect.y + nextOffsetY;\n        nextPopupBottom = nextPopupY + popupHeight;\n        nextPopupX = popupRect.x + nextOffsetX;\n        nextPopupRight = nextPopupX + popupWidth;\n      };\n\n      var _popupElement$parentE, _popupRect$x, _popupRect$y, _popupElement$parentE2;\n\n      var popupElement = popupEle;\n      var doc = popupElement.ownerDocument;\n      var win = getWin(popupElement);\n\n      var _win$getComputedStyle = win.getComputedStyle(popupElement),\n          width = _win$getComputedStyle.width,\n          height = _win$getComputedStyle.height,\n          popupPosition = _win$getComputedStyle.position;\n\n      var originLeft = popupElement.style.left;\n      var originTop = popupElement.style.top;\n      var originRight = popupElement.style.right;\n      var originBottom = popupElement.style.bottom;\n      var originOverflow = popupElement.style.overflow; // Placement\n\n      var placementInfo = _objectSpread(_objectSpread({}, builtinPlacements[placement]), popupAlign); // placeholder element\n\n\n      var placeholderElement = doc.createElement('div');\n      (_popupElement$parentE = popupElement.parentElement) === null || _popupElement$parentE === void 0 || _popupElement$parentE.appendChild(placeholderElement);\n      placeholderElement.style.left = \"\".concat(popupElement.offsetLeft, \"px\");\n      placeholderElement.style.top = \"\".concat(popupElement.offsetTop, \"px\");\n      placeholderElement.style.position = popupPosition;\n      placeholderElement.style.height = \"\".concat(popupElement.offsetHeight, \"px\");\n      placeholderElement.style.width = \"\".concat(popupElement.offsetWidth, \"px\"); // Reset first\n\n      popupElement.style.left = '0';\n      popupElement.style.top = '0';\n      popupElement.style.right = 'auto';\n      popupElement.style.bottom = 'auto';\n      popupElement.style.overflow = 'hidden'; // Calculate align style, we should consider `transform` case\n\n      var targetRect;\n\n      if (Array.isArray(target)) {\n        targetRect = {\n          x: target[0],\n          y: target[1],\n          width: 0,\n          height: 0\n        };\n      } else {\n        var _rect$x, _rect$y;\n\n        var rect = target.getBoundingClientRect();\n        rect.x = (_rect$x = rect.x) !== null && _rect$x !== void 0 ? _rect$x : rect.left;\n        rect.y = (_rect$y = rect.y) !== null && _rect$y !== void 0 ? _rect$y : rect.top;\n        targetRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      }\n\n      var popupRect = popupElement.getBoundingClientRect();\n      popupRect.x = (_popupRect$x = popupRect.x) !== null && _popupRect$x !== void 0 ? _popupRect$x : popupRect.left;\n      popupRect.y = (_popupRect$y = popupRect.y) !== null && _popupRect$y !== void 0 ? _popupRect$y : popupRect.top;\n      var _doc$documentElement = doc.documentElement,\n          clientWidth = _doc$documentElement.clientWidth,\n          clientHeight = _doc$documentElement.clientHeight,\n          scrollWidth = _doc$documentElement.scrollWidth,\n          scrollHeight = _doc$documentElement.scrollHeight,\n          scrollTop = _doc$documentElement.scrollTop,\n          scrollLeft = _doc$documentElement.scrollLeft;\n      var popupHeight = popupRect.height;\n      var popupWidth = popupRect.width;\n      var targetHeight = targetRect.height;\n      var targetWidth = targetRect.width; // Get bounding of visible area\n\n      var visibleRegion = {\n        left: 0,\n        top: 0,\n        right: clientWidth,\n        bottom: clientHeight\n      };\n      var scrollRegion = {\n        left: -scrollLeft,\n        top: -scrollTop,\n        right: scrollWidth - scrollLeft,\n        bottom: scrollHeight - scrollTop\n      };\n      var htmlRegion = placementInfo.htmlRegion;\n      var VISIBLE = 'visible';\n      var VISIBLE_FIRST = 'visibleFirst';\n\n      if (htmlRegion !== 'scroll' && htmlRegion !== VISIBLE_FIRST) {\n        htmlRegion = VISIBLE;\n      }\n\n      var isVisibleFirst = htmlRegion === VISIBLE_FIRST;\n      var scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);\n      var visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);\n      var visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea; // When set to `visibleFirst`,\n      // the check `adjust` logic will use `visibleRegion` for check first.\n\n      var adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea; // Record right & bottom align data\n\n      popupElement.style.left = 'auto';\n      popupElement.style.top = 'auto';\n      popupElement.style.right = '0';\n      popupElement.style.bottom = '0';\n      var popupMirrorRect = popupElement.getBoundingClientRect(); // Reset back\n\n      popupElement.style.left = originLeft;\n      popupElement.style.top = originTop;\n      popupElement.style.right = originRight;\n      popupElement.style.bottom = originBottom;\n      popupElement.style.overflow = originOverflow;\n      (_popupElement$parentE2 = popupElement.parentElement) === null || _popupElement$parentE2 === void 0 || _popupElement$parentE2.removeChild(placeholderElement); // Calculate scale\n\n      var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);\n\n      var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1000) / 1000); // No need to align since it's not visible in view\n\n\n      if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible(target)) {\n        return;\n      } // Offset\n\n\n      var offset = placementInfo.offset,\n          targetOffset = placementInfo.targetOffset;\n\n      var _getNumberOffset = getNumberOffset(popupRect, offset),\n          _getNumberOffset2 = _slicedToArray(_getNumberOffset, 2),\n          popupOffsetX = _getNumberOffset2[0],\n          popupOffsetY = _getNumberOffset2[1];\n\n      var _getNumberOffset3 = getNumberOffset(targetRect, targetOffset),\n          _getNumberOffset4 = _slicedToArray(_getNumberOffset3, 2),\n          targetOffsetX = _getNumberOffset4[0],\n          targetOffsetY = _getNumberOffset4[1];\n\n      targetRect.x -= targetOffsetX;\n      targetRect.y -= targetOffsetY; // Points\n\n      var _ref3 = placementInfo.points || [],\n          _ref4 = _slicedToArray(_ref3, 2),\n          popupPoint = _ref4[0],\n          targetPoint = _ref4[1];\n\n      var targetPoints = splitPoints(targetPoint);\n      var popupPoints = splitPoints(popupPoint);\n      var targetAlignPoint = getAlignPoint(targetRect, targetPoints);\n      var popupAlignPoint = getAlignPoint(popupRect, popupPoints); // Real align info may not same as origin one\n\n      var nextAlignInfo = _objectSpread({}, placementInfo); // Next Offset\n\n\n      var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;\n      var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;\n      var originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY); // As `visibleFirst`, we prepare this for check\n\n      var originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea); // ========================== Overflow ===========================\n\n      var targetAlignPointTL = getAlignPoint(targetRect, ['t', 'l']);\n      var popupAlignPointTL = getAlignPoint(popupRect, ['t', 'l']);\n      var targetAlignPointBR = getAlignPoint(targetRect, ['b', 'r']);\n      var popupAlignPointBR = getAlignPoint(popupRect, ['b', 'r']);\n      var overflow = placementInfo.overflow || {};\n      var adjustX = overflow.adjustX,\n          adjustY = overflow.adjustY,\n          shiftX = overflow.shiftX,\n          shiftY = overflow.shiftY;\n\n      var supportAdjust = function supportAdjust(val) {\n        if (typeof val === 'boolean') {\n          return val;\n        }\n\n        return val >= 0;\n      }; // Prepare position\n\n\n      var nextPopupY;\n      var nextPopupBottom;\n      var nextPopupX;\n      var nextPopupRight;\n      syncNextPopupPosition(); // >>>>>>>>>> Top & Bottom\n\n      var needAdjustY = supportAdjust(adjustY);\n      var sameTB = popupPoints[0] === targetPoints[0]; // Bottom to Top\n\n      if (needAdjustY && popupPoints[0] === 't' && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {\n        var tmpNextOffsetY = nextOffsetY;\n\n        if (sameTB) {\n          tmpNextOffsetY -= popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;\n        }\n\n        var newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);\n        var newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);\n\n        if ( // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.bt = true;\n          nextOffsetY = tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        } else {\n          prevFlipRef.current.bt = false;\n        }\n      } // Top to Bottom\n\n\n      if (needAdjustY && popupPoints[0] === 'b' && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {\n        var _tmpNextOffsetY = nextOffsetY;\n\n        if (sameTB) {\n          _tmpNextOffsetY += popupHeight - targetHeight;\n        } else {\n          _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;\n        }\n\n        var _newVisibleArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY);\n\n        var _newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY, visibleRegionArea);\n\n        if ( // Of course use larger one\n        _newVisibleArea > originIntersectionVisibleArea || _newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one\n        _newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.tb = true;\n          nextOffsetY = _tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        } else {\n          prevFlipRef.current.tb = false;\n        }\n      } // >>>>>>>>>> Left & Right\n\n\n      var needAdjustX = supportAdjust(adjustX); // >>>>> Flip\n\n      var sameLR = popupPoints[1] === targetPoints[1]; // Right to Left\n\n      if (needAdjustX && popupPoints[1] === 'l' && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {\n        var tmpNextOffsetX = nextOffsetX;\n\n        if (sameLR) {\n          tmpNextOffsetX -= popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;\n        }\n\n        var _newVisibleArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);\n\n        var _newVisibleRecommendArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n\n        if ( // Of course use larger one\n        _newVisibleArea2 > originIntersectionVisibleArea || _newVisibleArea2 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one\n        _newVisibleRecommendArea2 >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.rl = true;\n          nextOffsetX = tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        } else {\n          prevFlipRef.current.rl = false;\n        }\n      } // Left to Right\n\n\n      if (needAdjustX && popupPoints[1] === 'r' && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {\n        var _tmpNextOffsetX = nextOffsetX;\n\n        if (sameLR) {\n          _tmpNextOffsetX += popupWidth - targetWidth;\n        } else {\n          _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;\n        }\n\n        var _newVisibleArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY);\n\n        var _newVisibleRecommendArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n\n        if ( // Of course use larger one\n        _newVisibleArea3 > originIntersectionVisibleArea || _newVisibleArea3 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one\n        _newVisibleRecommendArea3 >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.lr = true;\n          nextOffsetX = _tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        } else {\n          prevFlipRef.current.lr = false;\n        }\n      } // ============================ Shift ============================\n\n\n      syncNextPopupPosition();\n      var numShiftX = shiftX === true ? 0 : shiftX;\n\n      if (typeof numShiftX === 'number') {\n        // Left\n        if (nextPopupX < visibleRegionArea.left) {\n          nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;\n\n          if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;\n          }\n        } // Right\n\n\n        if (nextPopupRight > visibleRegionArea.right) {\n          nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;\n\n          if (targetRect.x > visibleRegionArea.right - numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;\n          }\n        }\n      }\n\n      var numShiftY = shiftY === true ? 0 : shiftY;\n\n      if (typeof numShiftY === 'number') {\n        // Top\n        if (nextPopupY < visibleRegionArea.top) {\n          nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY; // When target if far away from visible area\n          // Stop shift\n\n          if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;\n          }\n        } // Bottom\n\n\n        if (nextPopupBottom > visibleRegionArea.bottom) {\n          nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;\n\n          if (targetRect.y > visibleRegionArea.bottom - numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;\n          }\n        }\n      } // ============================ Arrow ============================\n      // Arrow center align\n\n\n      var popupLeft = popupRect.x + nextOffsetX;\n      var popupRight = popupLeft + popupWidth;\n      var popupTop = popupRect.y + nextOffsetY;\n      var popupBottom = popupTop + popupHeight;\n      var targetLeft = targetRect.x;\n      var targetRight = targetLeft + targetWidth;\n      var targetTop = targetRect.y;\n      var targetBottom = targetTop + targetHeight;\n      var maxLeft = Math.max(popupLeft, targetLeft);\n      var minRight = Math.min(popupRight, targetRight);\n      var xCenter = (maxLeft + minRight) / 2;\n      var nextArrowX = xCenter - popupLeft;\n      var maxTop = Math.max(popupTop, targetTop);\n      var minBottom = Math.min(popupBottom, targetBottom);\n      var yCenter = (maxTop + minBottom) / 2;\n      var nextArrowY = yCenter - popupTop;\n      onPopupAlign === null || onPopupAlign === void 0 || onPopupAlign(popupEle, nextAlignInfo); // Additional calculate right & bottom position\n\n      var offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);\n      var offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);\n\n      if (_scaleX === 1) {\n        nextOffsetX = Math.round(nextOffsetX);\n        offsetX4Right = Math.round(offsetX4Right);\n      }\n\n      if (_scaleY === 1) {\n        nextOffsetY = Math.round(nextOffsetY);\n        offsetY4Bottom = Math.round(offsetY4Bottom);\n      }\n\n      var nextOffsetInfo = {\n        ready: true,\n        offsetX: nextOffsetX / _scaleX,\n        offsetY: nextOffsetY / _scaleY,\n        offsetR: offsetX4Right / _scaleX,\n        offsetB: offsetY4Bottom / _scaleY,\n        arrowX: nextArrowX / _scaleX,\n        arrowY: nextArrowY / _scaleY,\n        scaleX: _scaleX,\n        scaleY: _scaleY,\n        align: nextAlignInfo\n      };\n      setOffsetInfo(nextOffsetInfo);\n    }\n  });\n\n  var triggerAlign = function triggerAlign() {\n    alignCountRef.current += 1;\n    var id = alignCountRef.current; // Merge all align requirement into one frame\n\n    Promise.resolve().then(function () {\n      if (alignCountRef.current === id) {\n        onAlign();\n      }\n    });\n  }; // Reset ready status when placement & open changed\n\n\n  var resetReady = function resetReady() {\n    setOffsetInfo(function (ori) {\n      return _objectSpread(_objectSpread({}, ori), {}, {\n        ready: false\n      });\n    });\n  };\n\n  useLayoutEffect(resetReady, [placement]);\n  useLayoutEffect(function () {\n    if (!open) {\n      resetReady();\n    }\n  }, [open]);\n  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];\n}","map":{"version":3,"sources":["/Users/shamryshiraz/Documents/New/Untitled/Portfolio/node_modules/@rc-component/trigger/es/hooks/useAlign.js"],"names":["_objectSpread","_slicedToArray","isDOM","isVisible","useEvent","useLayoutEffect","React","collectScroller","getVisibleArea","getWin","toNum","getUnitOffset","size","offset","arguments","length","undefined","offsetStr","concat","cells","match","parseFloat","getNumberOffset","rect","_ref","_ref2","offsetX","offsetY","width","height","splitPoints","points","getAlignPoint","topBottom","leftRight","x","y","reversePoints","index","reverseMap","t","b","l","r","map","point","i","join","useAlign","open","popupEle","target","placement","builtinPlacements","popupAlign","onPopupAlign","_React$useState","useState","ready","offsetR","offsetB","arrowX","arrowY","scaleX","scaleY","align","_React$useState2","offsetInfo","setOffsetInfo","alignCountRef","useRef","scrollerList","useMemo","prevFlipRef","resetFlipCache","current","onAlign","getIntersectionVisibleArea","area","visibleArea","popupRect","popupWidth","popupHeight","visibleL","Math","max","left","visibleT","top","visibleR","min","right","visibleB","bottom","syncNextPopupPosition","nextPopupY","nextOffsetY","nextPopupBottom","nextPopupX","nextOffsetX","nextPopupRight","_popupElement$parentE","_popupRect$x","_popupRect$y","_popupElement$parentE2","popupElement","doc","ownerDocument","win","_win$getComputedStyle","getComputedStyle","popupPosition","position","originLeft","style","originTop","originRight","originBottom","originOverflow","overflow","placementInfo","placeholderElement","createElement","parentElement","appendChild","offsetLeft","offsetTop","offsetHeight","offsetWidth","targetRect","Array","isArray","_rect$x","_rect$y","getBoundingClientRect","_doc$documentElement","documentElement","clientWidth","clientHeight","scrollWidth","scrollHeight","scrollTop","scrollLeft","targetHeight","targetWidth","visibleRegion","scrollRegion","htmlRegion","VISIBLE","VISIBLE_FIRST","isVisibleFirst","scrollRegionArea","visibleRegionArea","adjustCheckVisibleArea","popupMirrorRect","removeChild","_scaleX","round","_scaleY","targetOffset","_getNumberOffset","_getNumberOffset2","popupOffsetX","popupOffsetY","_getNumberOffset3","_getNumberOffset4","targetOffsetX","targetOffsetY","_ref3","_ref4","popupPoint","targetPoint","targetPoints","popupPoints","targetAlignPoint","popupAlignPoint","nextAlignInfo","originIntersectionVisibleArea","originIntersectionRecommendArea","targetAlignPointTL","popupAlignPointTL","targetAlignPointBR","popupAlignPointBR","adjustX","adjustY","shiftX","shiftY","supportAdjust","val","needAdjustY","sameTB","bt","tmpNextOffsetY","newVisibleArea","newVisibleRecommendArea","tb","_tmpNextOffsetY","_newVisibleArea","_newVisibleRecommendArea","needAdjustX","sameLR","rl","tmpNextOffsetX","_newVisibleArea2","_newVisibleRecommendArea2","lr","_tmpNextOffsetX","_newVisibleArea3","_newVisibleRecommendArea3","numShiftX","numShiftY","popupLeft","popupRight","popupTop","popupBottom","targetLeft","targetRight","targetTop","targetBottom","maxLeft","minRight","xCenter","nextArrowX","maxTop","minBottom","yCenter","nextArrowY","offsetX4Right","offsetY4Bottom","nextOffsetInfo","triggerAlign","id","Promise","resolve","then","resetReady","ori"],"mappings":"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","sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { isDOM } from \"rc-util/es/Dom/findDOMNode\";\nimport isVisible from \"rc-util/es/Dom/isVisible\";\nimport useEvent from \"rc-util/es/hooks/useEvent\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport { collectScroller, getVisibleArea, getWin, toNum } from \"../util\";\nfunction getUnitOffset(size) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var offsetStr = \"\".concat(offset);\n  var cells = offsetStr.match(/^(.*)\\%$/);\n  if (cells) {\n    return size * (parseFloat(cells[1]) / 100);\n  }\n  return parseFloat(offsetStr);\n}\nfunction getNumberOffset(rect, offset) {\n  var _ref = offset || [],\n    _ref2 = _slicedToArray(_ref, 2),\n    offsetX = _ref2[0],\n    offsetY = _ref2[1];\n  return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];\n}\nfunction splitPoints() {\n  var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return [points[0], points[1]];\n}\nfunction getAlignPoint(rect, points) {\n  var topBottom = points[0];\n  var leftRight = points[1];\n  var x;\n  var y;\n\n  // Top & Bottom\n  if (topBottom === 't') {\n    y = rect.y;\n  } else if (topBottom === 'b') {\n    y = rect.y + rect.height;\n  } else {\n    y = rect.y + rect.height / 2;\n  }\n\n  // Left & Right\n  if (leftRight === 'l') {\n    x = rect.x;\n  } else if (leftRight === 'r') {\n    x = rect.x + rect.width;\n  } else {\n    x = rect.x + rect.width / 2;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction reversePoints(points, index) {\n  var reverseMap = {\n    t: 'b',\n    b: 't',\n    l: 'r',\n    r: 'l'\n  };\n  return points.map(function (point, i) {\n    if (i === index) {\n      return reverseMap[point] || 'c';\n    }\n    return point;\n  }).join('');\n}\nexport default function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {\n  var _React$useState = React.useState({\n      ready: false,\n      offsetX: 0,\n      offsetY: 0,\n      offsetR: 0,\n      offsetB: 0,\n      arrowX: 0,\n      arrowY: 0,\n      scaleX: 1,\n      scaleY: 1,\n      align: builtinPlacements[placement] || {}\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    offsetInfo = _React$useState2[0],\n    setOffsetInfo = _React$useState2[1];\n  var alignCountRef = React.useRef(0);\n  var scrollerList = React.useMemo(function () {\n    if (!popupEle) {\n      return [];\n    }\n    return collectScroller(popupEle);\n  }, [popupEle]);\n\n  // ========================= Flip ==========================\n  // We will memo flip info.\n  // If size change to make flip, it will memo the flip info and use it in next align.\n  var prevFlipRef = React.useRef({});\n  var resetFlipCache = function resetFlipCache() {\n    prevFlipRef.current = {};\n  };\n  if (!open) {\n    resetFlipCache();\n  }\n\n  // ========================= Align =========================\n  var onAlign = useEvent(function () {\n    if (popupEle && target && open) {\n      var _popupElement$parentE, _popupRect$x, _popupRect$y, _popupElement$parentE2;\n      var popupElement = popupEle;\n      var doc = popupElement.ownerDocument;\n      var win = getWin(popupElement);\n      var _win$getComputedStyle = win.getComputedStyle(popupElement),\n        width = _win$getComputedStyle.width,\n        height = _win$getComputedStyle.height,\n        popupPosition = _win$getComputedStyle.position;\n      var originLeft = popupElement.style.left;\n      var originTop = popupElement.style.top;\n      var originRight = popupElement.style.right;\n      var originBottom = popupElement.style.bottom;\n      var originOverflow = popupElement.style.overflow;\n\n      // Placement\n      var placementInfo = _objectSpread(_objectSpread({}, builtinPlacements[placement]), popupAlign);\n\n      // placeholder element\n      var placeholderElement = doc.createElement('div');\n      (_popupElement$parentE = popupElement.parentElement) === null || _popupElement$parentE === void 0 || _popupElement$parentE.appendChild(placeholderElement);\n      placeholderElement.style.left = \"\".concat(popupElement.offsetLeft, \"px\");\n      placeholderElement.style.top = \"\".concat(popupElement.offsetTop, \"px\");\n      placeholderElement.style.position = popupPosition;\n      placeholderElement.style.height = \"\".concat(popupElement.offsetHeight, \"px\");\n      placeholderElement.style.width = \"\".concat(popupElement.offsetWidth, \"px\");\n\n      // Reset first\n      popupElement.style.left = '0';\n      popupElement.style.top = '0';\n      popupElement.style.right = 'auto';\n      popupElement.style.bottom = 'auto';\n      popupElement.style.overflow = 'hidden';\n\n      // Calculate align style, we should consider `transform` case\n      var targetRect;\n      if (Array.isArray(target)) {\n        targetRect = {\n          x: target[0],\n          y: target[1],\n          width: 0,\n          height: 0\n        };\n      } else {\n        var _rect$x, _rect$y;\n        var rect = target.getBoundingClientRect();\n        rect.x = (_rect$x = rect.x) !== null && _rect$x !== void 0 ? _rect$x : rect.left;\n        rect.y = (_rect$y = rect.y) !== null && _rect$y !== void 0 ? _rect$y : rect.top;\n        targetRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      }\n      var popupRect = popupElement.getBoundingClientRect();\n      popupRect.x = (_popupRect$x = popupRect.x) !== null && _popupRect$x !== void 0 ? _popupRect$x : popupRect.left;\n      popupRect.y = (_popupRect$y = popupRect.y) !== null && _popupRect$y !== void 0 ? _popupRect$y : popupRect.top;\n      var _doc$documentElement = doc.documentElement,\n        clientWidth = _doc$documentElement.clientWidth,\n        clientHeight = _doc$documentElement.clientHeight,\n        scrollWidth = _doc$documentElement.scrollWidth,\n        scrollHeight = _doc$documentElement.scrollHeight,\n        scrollTop = _doc$documentElement.scrollTop,\n        scrollLeft = _doc$documentElement.scrollLeft;\n      var popupHeight = popupRect.height;\n      var popupWidth = popupRect.width;\n      var targetHeight = targetRect.height;\n      var targetWidth = targetRect.width;\n\n      // Get bounding of visible area\n      var visibleRegion = {\n        left: 0,\n        top: 0,\n        right: clientWidth,\n        bottom: clientHeight\n      };\n      var scrollRegion = {\n        left: -scrollLeft,\n        top: -scrollTop,\n        right: scrollWidth - scrollLeft,\n        bottom: scrollHeight - scrollTop\n      };\n      var htmlRegion = placementInfo.htmlRegion;\n      var VISIBLE = 'visible';\n      var VISIBLE_FIRST = 'visibleFirst';\n      if (htmlRegion !== 'scroll' && htmlRegion !== VISIBLE_FIRST) {\n        htmlRegion = VISIBLE;\n      }\n      var isVisibleFirst = htmlRegion === VISIBLE_FIRST;\n      var scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);\n      var visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);\n      var visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;\n\n      // When set to `visibleFirst`,\n      // the check `adjust` logic will use `visibleRegion` for check first.\n      var adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;\n\n      // Record right & bottom align data\n      popupElement.style.left = 'auto';\n      popupElement.style.top = 'auto';\n      popupElement.style.right = '0';\n      popupElement.style.bottom = '0';\n      var popupMirrorRect = popupElement.getBoundingClientRect();\n\n      // Reset back\n      popupElement.style.left = originLeft;\n      popupElement.style.top = originTop;\n      popupElement.style.right = originRight;\n      popupElement.style.bottom = originBottom;\n      popupElement.style.overflow = originOverflow;\n      (_popupElement$parentE2 = popupElement.parentElement) === null || _popupElement$parentE2 === void 0 || _popupElement$parentE2.removeChild(placeholderElement);\n\n      // Calculate scale\n      var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);\n      var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1000) / 1000);\n\n      // No need to align since it's not visible in view\n      if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible(target)) {\n        return;\n      }\n\n      // Offset\n      var offset = placementInfo.offset,\n        targetOffset = placementInfo.targetOffset;\n      var _getNumberOffset = getNumberOffset(popupRect, offset),\n        _getNumberOffset2 = _slicedToArray(_getNumberOffset, 2),\n        popupOffsetX = _getNumberOffset2[0],\n        popupOffsetY = _getNumberOffset2[1];\n      var _getNumberOffset3 = getNumberOffset(targetRect, targetOffset),\n        _getNumberOffset4 = _slicedToArray(_getNumberOffset3, 2),\n        targetOffsetX = _getNumberOffset4[0],\n        targetOffsetY = _getNumberOffset4[1];\n      targetRect.x -= targetOffsetX;\n      targetRect.y -= targetOffsetY;\n\n      // Points\n      var _ref3 = placementInfo.points || [],\n        _ref4 = _slicedToArray(_ref3, 2),\n        popupPoint = _ref4[0],\n        targetPoint = _ref4[1];\n      var targetPoints = splitPoints(targetPoint);\n      var popupPoints = splitPoints(popupPoint);\n      var targetAlignPoint = getAlignPoint(targetRect, targetPoints);\n      var popupAlignPoint = getAlignPoint(popupRect, popupPoints);\n\n      // Real align info may not same as origin one\n      var nextAlignInfo = _objectSpread({}, placementInfo);\n\n      // Next Offset\n      var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;\n      var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;\n\n      // ============== Intersection ===============\n      // Get area by position. Used for check if flip area is better\n      function getIntersectionVisibleArea(offsetX, offsetY) {\n        var area = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : visibleArea;\n        var l = popupRect.x + offsetX;\n        var t = popupRect.y + offsetY;\n        var r = l + popupWidth;\n        var b = t + popupHeight;\n        var visibleL = Math.max(l, area.left);\n        var visibleT = Math.max(t, area.top);\n        var visibleR = Math.min(r, area.right);\n        var visibleB = Math.min(b, area.bottom);\n        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));\n      }\n      var originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);\n\n      // As `visibleFirst`, we prepare this for check\n      var originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);\n\n      // ========================== Overflow ===========================\n      var targetAlignPointTL = getAlignPoint(targetRect, ['t', 'l']);\n      var popupAlignPointTL = getAlignPoint(popupRect, ['t', 'l']);\n      var targetAlignPointBR = getAlignPoint(targetRect, ['b', 'r']);\n      var popupAlignPointBR = getAlignPoint(popupRect, ['b', 'r']);\n      var overflow = placementInfo.overflow || {};\n      var adjustX = overflow.adjustX,\n        adjustY = overflow.adjustY,\n        shiftX = overflow.shiftX,\n        shiftY = overflow.shiftY;\n      var supportAdjust = function supportAdjust(val) {\n        if (typeof val === 'boolean') {\n          return val;\n        }\n        return val >= 0;\n      };\n\n      // Prepare position\n      var nextPopupY;\n      var nextPopupBottom;\n      var nextPopupX;\n      var nextPopupRight;\n      function syncNextPopupPosition() {\n        nextPopupY = popupRect.y + nextOffsetY;\n        nextPopupBottom = nextPopupY + popupHeight;\n        nextPopupX = popupRect.x + nextOffsetX;\n        nextPopupRight = nextPopupX + popupWidth;\n      }\n      syncNextPopupPosition();\n\n      // >>>>>>>>>> Top & Bottom\n      var needAdjustY = supportAdjust(adjustY);\n      var sameTB = popupPoints[0] === targetPoints[0];\n\n      // Bottom to Top\n      if (needAdjustY && popupPoints[0] === 't' && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {\n        var tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          tmpNextOffsetY -= popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;\n        }\n        var newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);\n        var newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.bt = true;\n          nextOffsetY = tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        } else {\n          prevFlipRef.current.bt = false;\n        }\n      }\n\n      // Top to Bottom\n      if (needAdjustY && popupPoints[0] === 'b' && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {\n        var _tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          _tmpNextOffsetY += popupHeight - targetHeight;\n        } else {\n          _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;\n        }\n        var _newVisibleArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY);\n        var _newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        _newVisibleArea > originIntersectionVisibleArea || _newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        _newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.tb = true;\n          nextOffsetY = _tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        } else {\n          prevFlipRef.current.tb = false;\n        }\n      }\n\n      // >>>>>>>>>> Left & Right\n      var needAdjustX = supportAdjust(adjustX);\n\n      // >>>>> Flip\n      var sameLR = popupPoints[1] === targetPoints[1];\n\n      // Right to Left\n      if (needAdjustX && popupPoints[1] === 'l' && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {\n        var tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          tmpNextOffsetX -= popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;\n        }\n        var _newVisibleArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);\n        var _newVisibleRecommendArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        _newVisibleArea2 > originIntersectionVisibleArea || _newVisibleArea2 === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        _newVisibleRecommendArea2 >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.rl = true;\n          nextOffsetX = tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        } else {\n          prevFlipRef.current.rl = false;\n        }\n      }\n\n      // Left to Right\n      if (needAdjustX && popupPoints[1] === 'r' && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {\n        var _tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          _tmpNextOffsetX += popupWidth - targetWidth;\n        } else {\n          _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;\n        }\n        var _newVisibleArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY);\n        var _newVisibleRecommendArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        _newVisibleArea3 > originIntersectionVisibleArea || _newVisibleArea3 === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        _newVisibleRecommendArea3 >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.lr = true;\n          nextOffsetX = _tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        } else {\n          prevFlipRef.current.lr = false;\n        }\n      }\n\n      // ============================ Shift ============================\n      syncNextPopupPosition();\n      var numShiftX = shiftX === true ? 0 : shiftX;\n      if (typeof numShiftX === 'number') {\n        // Left\n        if (nextPopupX < visibleRegionArea.left) {\n          nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;\n          if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;\n          }\n        }\n\n        // Right\n        if (nextPopupRight > visibleRegionArea.right) {\n          nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;\n          if (targetRect.x > visibleRegionArea.right - numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;\n          }\n        }\n      }\n      var numShiftY = shiftY === true ? 0 : shiftY;\n      if (typeof numShiftY === 'number') {\n        // Top\n        if (nextPopupY < visibleRegionArea.top) {\n          nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;\n\n          // When target if far away from visible area\n          // Stop shift\n          if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;\n          }\n        }\n\n        // Bottom\n        if (nextPopupBottom > visibleRegionArea.bottom) {\n          nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;\n          if (targetRect.y > visibleRegionArea.bottom - numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;\n          }\n        }\n      }\n\n      // ============================ Arrow ============================\n      // Arrow center align\n      var popupLeft = popupRect.x + nextOffsetX;\n      var popupRight = popupLeft + popupWidth;\n      var popupTop = popupRect.y + nextOffsetY;\n      var popupBottom = popupTop + popupHeight;\n      var targetLeft = targetRect.x;\n      var targetRight = targetLeft + targetWidth;\n      var targetTop = targetRect.y;\n      var targetBottom = targetTop + targetHeight;\n      var maxLeft = Math.max(popupLeft, targetLeft);\n      var minRight = Math.min(popupRight, targetRight);\n      var xCenter = (maxLeft + minRight) / 2;\n      var nextArrowX = xCenter - popupLeft;\n      var maxTop = Math.max(popupTop, targetTop);\n      var minBottom = Math.min(popupBottom, targetBottom);\n      var yCenter = (maxTop + minBottom) / 2;\n      var nextArrowY = yCenter - popupTop;\n      onPopupAlign === null || onPopupAlign === void 0 || onPopupAlign(popupEle, nextAlignInfo);\n\n      // Additional calculate right & bottom position\n      var offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);\n      var offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);\n      if (_scaleX === 1) {\n        nextOffsetX = Math.round(nextOffsetX);\n        offsetX4Right = Math.round(offsetX4Right);\n      }\n      if (_scaleY === 1) {\n        nextOffsetY = Math.round(nextOffsetY);\n        offsetY4Bottom = Math.round(offsetY4Bottom);\n      }\n      var nextOffsetInfo = {\n        ready: true,\n        offsetX: nextOffsetX / _scaleX,\n        offsetY: nextOffsetY / _scaleY,\n        offsetR: offsetX4Right / _scaleX,\n        offsetB: offsetY4Bottom / _scaleY,\n        arrowX: nextArrowX / _scaleX,\n        arrowY: nextArrowY / _scaleY,\n        scaleX: _scaleX,\n        scaleY: _scaleY,\n        align: nextAlignInfo\n      };\n      setOffsetInfo(nextOffsetInfo);\n    }\n  });\n  var triggerAlign = function triggerAlign() {\n    alignCountRef.current += 1;\n    var id = alignCountRef.current;\n\n    // Merge all align requirement into one frame\n    Promise.resolve().then(function () {\n      if (alignCountRef.current === id) {\n        onAlign();\n      }\n    });\n  };\n\n  // Reset ready status when placement & open changed\n  var resetReady = function resetReady() {\n    setOffsetInfo(function (ori) {\n      return _objectSpread(_objectSpread({}, ori), {}, {\n        ready: false\n      });\n    });\n  };\n  useLayoutEffect(resetReady, [placement]);\n  useLayoutEffect(function () {\n    if (!open) {\n      resetReady();\n    }\n  }, [open]);\n  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];\n}"]},"metadata":{},"sourceType":"module"}