{"ast":null,"code":"import _defineProperty from \"/Users/shamryshiraz/Documents/New/Untitled/Portfolio/New/Portfolio-Ruwan-Prasanna/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/Users/shamryshiraz/Documents/New/Untitled/Portfolio/New/Portfolio-Ruwan-Prasanna/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/shamryshiraz/Documents/New/Untitled/Portfolio/New/Portfolio-Ruwan-Prasanna/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport React from 'react';\nimport { useToken } from '../theme/internal';\nimport { addMediaQueryListener, removeMediaQueryListener } from './mediaQueryUtil';\nexport var responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\n\nvar getResponsiveMap = function getResponsiveMap(token) {\n  return {\n    xs: \"(max-width: \".concat(token.screenXSMax, \"px)\"),\n    sm: \"(min-width: \".concat(token.screenSM, \"px)\"),\n    md: \"(min-width: \".concat(token.screenMD, \"px)\"),\n    lg: \"(min-width: \".concat(token.screenLG, \"px)\"),\n    xl: \"(min-width: \".concat(token.screenXL, \"px)\"),\n    xxl: \"(min-width: \".concat(token.screenXXL, \"px)\")\n  };\n};\n/**\n * Ensures that the breakpoints token are valid, in good order\n * For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin\n */\n\n\nvar validateBreakpoints = function validateBreakpoints(token) {\n  var indexableToken = token;\n  var revBreakpoints = [].concat(responsiveArray).reverse();\n  revBreakpoints.forEach(function (breakpoint, i) {\n    var breakpointUpper = breakpoint.toUpperCase();\n    var screenMin = \"screen\".concat(breakpointUpper, \"Min\");\n    var screen = \"screen\".concat(breakpointUpper);\n\n    if (!(indexableToken[screenMin] <= indexableToken[screen])) {\n      throw new Error(\"\".concat(screenMin, \"<=\").concat(screen, \" fails : !(\").concat(indexableToken[screenMin], \"<=\").concat(indexableToken[screen], \")\"));\n    }\n\n    if (i < revBreakpoints.length - 1) {\n      var screenMax = \"screen\".concat(breakpointUpper, \"Max\");\n\n      if (!(indexableToken[screen] <= indexableToken[screenMax])) {\n        throw new Error(\"\".concat(screen, \"<=\").concat(screenMax, \" fails : !(\").concat(indexableToken[screen], \"<=\").concat(indexableToken[screenMax], \")\"));\n      }\n\n      var nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();\n      var nextScreenMin = \"screen\".concat(nextBreakpointUpperMin, \"Min\");\n\n      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {\n        throw new Error(\"\".concat(screenMax, \"<=\").concat(nextScreenMin, \" fails : !(\").concat(indexableToken[screenMax], \"<=\").concat(indexableToken[nextScreenMin], \")\"));\n      }\n    }\n  });\n  return token;\n};\n\nexport var matchScreen = function matchScreen(screens, screenSizes) {\n  if (!screenSizes) {\n    return;\n  }\n\n  var _iterator = _createForOfIteratorHelper(responsiveArray),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var breakpoint = _step.value;\n\n      if (screens[breakpoint] && (screenSizes === null || screenSizes === void 0 ? void 0 : screenSizes[breakpoint]) !== undefined) {\n        return screenSizes[breakpoint];\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\n\nvar useResponsiveObserver = function useResponsiveObserver() {\n  var _useToken = useToken(),\n      _useToken2 = _slicedToArray(_useToken, 2),\n      token = _useToken2[1];\n\n  var responsiveMap = getResponsiveMap(validateBreakpoints(token)); // To avoid repeat create instance, we add `useMemo` here.\n\n  return React.useMemo(function () {\n    var subscribers = new Map();\n    var subUid = -1;\n    var screens = {};\n    return {\n      responsiveMap: responsiveMap,\n      matchHandlers: {},\n      dispatch: function dispatch(pointMap) {\n        screens = pointMap;\n        subscribers.forEach(function (func) {\n          return func(screens);\n        });\n        return subscribers.size >= 1;\n      },\n      subscribe: function subscribe(func) {\n        if (!subscribers.size) {\n          this.register();\n        }\n\n        subUid += 1;\n        subscribers.set(subUid, func);\n        func(screens);\n        return subUid;\n      },\n      unsubscribe: function unsubscribe(paramToken) {\n        subscribers.delete(paramToken);\n\n        if (!subscribers.size) {\n          this.unregister();\n        }\n      },\n      register: function register() {\n        var _this = this;\n\n        Object.entries(responsiveMap).forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              screen = _ref2[0],\n              mediaQuery = _ref2[1];\n\n          var listener = function listener(_ref3) {\n            var matches = _ref3.matches;\n\n            _this.dispatch(Object.assign(Object.assign({}, screens), _defineProperty({}, screen, matches)));\n          };\n\n          var mql = window.matchMedia(mediaQuery);\n          addMediaQueryListener(mql, listener);\n          _this.matchHandlers[mediaQuery] = {\n            mql: mql,\n            listener: listener\n          };\n          listener(mql);\n        });\n      },\n      unregister: function unregister() {\n        var _this2 = this;\n\n        Object.values(responsiveMap).forEach(function (mediaQuery) {\n          var handler = _this2.matchHandlers[mediaQuery];\n          removeMediaQueryListener(handler === null || handler === void 0 ? void 0 : handler.mql, handler === null || handler === void 0 ? void 0 : handler.listener);\n        });\n        subscribers.clear();\n      }\n    };\n  }, [token]);\n};\n\nexport default useResponsiveObserver;","map":{"version":3,"sources":["/Users/shamryshiraz/Documents/New/Untitled/Portfolio/New/Portfolio-Ruwan-Prasanna/node_modules/antd/es/_util/responsiveObserver.js"],"names":["React","useToken","addMediaQueryListener","removeMediaQueryListener","responsiveArray","getResponsiveMap","token","xs","screenXSMax","sm","screenSM","md","screenMD","lg","screenLG","xl","screenXL","xxl","screenXXL","validateBreakpoints","indexableToken","revBreakpoints","concat","reverse","forEach","breakpoint","i","breakpointUpper","toUpperCase","screenMin","screen","Error","length","screenMax","nextBreakpointUpperMin","nextScreenMin","matchScreen","screens","screenSizes","undefined","useResponsiveObserver","responsiveMap","useMemo","subscribers","Map","subUid","matchHandlers","dispatch","pointMap","func","size","subscribe","register","set","unsubscribe","paramToken","delete","unregister","Object","entries","mediaQuery","listener","matches","assign","mql","window","matchMedia","values","handler","clear"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { useToken } from '../theme/internal';\nimport { addMediaQueryListener, removeMediaQueryListener } from './mediaQueryUtil';\nexport const responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\nconst getResponsiveMap = token => ({\n  xs: `(max-width: ${token.screenXSMax}px)`,\n  sm: `(min-width: ${token.screenSM}px)`,\n  md: `(min-width: ${token.screenMD}px)`,\n  lg: `(min-width: ${token.screenLG}px)`,\n  xl: `(min-width: ${token.screenXL}px)`,\n  xxl: `(min-width: ${token.screenXXL}px)`\n});\n/**\n * Ensures that the breakpoints token are valid, in good order\n * For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin\n */\nconst validateBreakpoints = token => {\n  const indexableToken = token;\n  const revBreakpoints = [].concat(responsiveArray).reverse();\n  revBreakpoints.forEach((breakpoint, i) => {\n    const breakpointUpper = breakpoint.toUpperCase();\n    const screenMin = `screen${breakpointUpper}Min`;\n    const screen = `screen${breakpointUpper}`;\n    if (!(indexableToken[screenMin] <= indexableToken[screen])) {\n      throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);\n    }\n    if (i < revBreakpoints.length - 1) {\n      const screenMax = `screen${breakpointUpper}Max`;\n      if (!(indexableToken[screen] <= indexableToken[screenMax])) {\n        throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);\n      }\n      const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();\n      const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;\n      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {\n        throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);\n      }\n    }\n  });\n  return token;\n};\nexport const matchScreen = (screens, screenSizes) => {\n  if (!screenSizes) {\n    return;\n  }\n  for (const breakpoint of responsiveArray) {\n    if (screens[breakpoint] && (screenSizes === null || screenSizes === void 0 ? void 0 : screenSizes[breakpoint]) !== undefined) {\n      return screenSizes[breakpoint];\n    }\n  }\n};\nconst useResponsiveObserver = () => {\n  const [, token] = useToken();\n  const responsiveMap = getResponsiveMap(validateBreakpoints(token));\n  // To avoid repeat create instance, we add `useMemo` here.\n  return React.useMemo(() => {\n    const subscribers = new Map();\n    let subUid = -1;\n    let screens = {};\n    return {\n      responsiveMap,\n      matchHandlers: {},\n      dispatch(pointMap) {\n        screens = pointMap;\n        subscribers.forEach(func => func(screens));\n        return subscribers.size >= 1;\n      },\n      subscribe(func) {\n        if (!subscribers.size) {\n          this.register();\n        }\n        subUid += 1;\n        subscribers.set(subUid, func);\n        func(screens);\n        return subUid;\n      },\n      unsubscribe(paramToken) {\n        subscribers.delete(paramToken);\n        if (!subscribers.size) {\n          this.unregister();\n        }\n      },\n      register() {\n        Object.entries(responsiveMap).forEach(([screen, mediaQuery]) => {\n          const listener = ({\n            matches\n          }) => {\n            this.dispatch(Object.assign(Object.assign({}, screens), {\n              [screen]: matches\n            }));\n          };\n          const mql = window.matchMedia(mediaQuery);\n          addMediaQueryListener(mql, listener);\n          this.matchHandlers[mediaQuery] = {\n            mql,\n            listener\n          };\n          listener(mql);\n        });\n      },\n      unregister() {\n        Object.values(responsiveMap).forEach(mediaQuery => {\n          const handler = this.matchHandlers[mediaQuery];\n          removeMediaQueryListener(handler === null || handler === void 0 ? void 0 : handler.mql, handler === null || handler === void 0 ? void 0 : handler.listener);\n        });\n        subscribers.clear();\n      }\n    };\n  }, [token]);\n};\nexport default useResponsiveObserver;"]},"metadata":{},"sourceType":"module"}