{"ast":null,"code":"import _slicedToArray from \"/Users/shamryshiraz/Documents/New/Untitled/Portfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport React from 'react';\nexport function getPtg(str) {\n  return Number(str.slice(0, -1)) / 100;\n}\n\nfunction isPtg(itemSize) {\n  return typeof itemSize === 'string' && itemSize.endsWith('%');\n}\n/**\n * Save the size state.\n * Align the size into flex percentage base.\n */\n\n\nexport default function useSizes(items, containerSize) {\n  var propSizes = items.map(function (item) {\n    return item.size;\n  });\n  var itemsCount = items.length;\n  var mergedContainerSize = containerSize || 0;\n\n  var ptg2px = function ptg2px(ptg) {\n    return ptg * mergedContainerSize;\n  }; // We do not need care the size state match the `items` length in `useState`.\n  // It will calculate later.\n\n\n  var _React$useState = React.useState(function () {\n    return items.map(function (item) {\n      return item.defaultSize;\n    });\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      innerSizes = _React$useState2[0],\n      setInnerSizes = _React$useState2[1];\n\n  var sizes = React.useMemo(function () {\n    var _a;\n\n    var mergedSizes = [];\n\n    for (var i = 0; i < itemsCount; i += 1) {\n      mergedSizes[i] = (_a = propSizes[i]) !== null && _a !== void 0 ? _a : innerSizes[i];\n    }\n\n    return mergedSizes;\n  }, [itemsCount, innerSizes, propSizes]); // Post handle the size. Will do:\n  // 1. Convert all the px into percentage if not empty.\n  // 2. Get rest percentage for exist percentage.\n  // 3. Fill the rest percentage into empty item.\n\n  var postPercentSizes = React.useMemo(function () {\n    var ptgList = [];\n    var emptyCount = 0; // Fill default percentage\n\n    for (var i = 0; i < itemsCount; i += 1) {\n      var itemSize = sizes[i];\n\n      if (isPtg(itemSize)) {\n        ptgList[i] = getPtg(itemSize);\n      } else if (itemSize || itemSize === 0) {\n        var num = Number(itemSize);\n\n        if (!Number.isNaN(num)) {\n          ptgList[i] = num / mergedContainerSize;\n        }\n      } else {\n        emptyCount += 1;\n        ptgList[i] = undefined;\n      }\n    }\n\n    var totalPtg = ptgList.reduce(function (acc, ptg) {\n      return acc + (ptg || 0);\n    }, 0);\n\n    if (totalPtg > 1 || !emptyCount) {\n      // If total percentage is larger than 1, we will scale it down.\n      var scale = 1 / totalPtg;\n      ptgList = ptgList.map(function (ptg) {\n        return ptg === undefined ? 0 : ptg * scale;\n      });\n    } else {\n      // If total percentage is smaller than 1, we will fill the rest.\n      var avgRest = (1 - totalPtg) / emptyCount;\n      ptgList = ptgList.map(function (ptg) {\n        return ptg === undefined ? avgRest : ptg;\n      });\n    }\n\n    return ptgList;\n  }, [sizes, mergedContainerSize]);\n  var postPxSizes = React.useMemo(function () {\n    return postPercentSizes.map(ptg2px);\n  }, [postPercentSizes, mergedContainerSize]);\n  var postPercentMinSizes = React.useMemo(function () {\n    return items.map(function (item) {\n      if (isPtg(item.min)) {\n        return getPtg(item.min);\n      }\n\n      return (item.min || 0) / mergedContainerSize;\n    });\n  }, [items, mergedContainerSize]);\n  var postPercentMaxSizes = React.useMemo(function () {\n    return items.map(function (item) {\n      if (isPtg(item.max)) {\n        return getPtg(item.max);\n      }\n\n      return (item.max || mergedContainerSize) / mergedContainerSize;\n    });\n  }, [items, mergedContainerSize]); // If ssr, we will use the size from developer config first.\n\n  var panelSizes = React.useMemo(function () {\n    return containerSize ? postPxSizes : sizes;\n  }, [postPxSizes, containerSize]);\n  return [panelSizes, postPxSizes, postPercentSizes, postPercentMinSizes, postPercentMaxSizes, setInnerSizes];\n}","map":{"version":3,"sources":["/Users/shamryshiraz/Documents/New/Untitled/Portfolio/node_modules/antd/es/splitter/hooks/useSizes.js"],"names":["React","getPtg","str","Number","slice","isPtg","itemSize","endsWith","useSizes","items","containerSize","propSizes","map","item","size","itemsCount","length","mergedContainerSize","ptg2px","ptg","useState","defaultSize","innerSizes","setInnerSizes","sizes","useMemo","_a","mergedSizes","i","postPercentSizes","ptgList","emptyCount","num","isNaN","undefined","totalPtg","reduce","acc","scale","avgRest","postPxSizes","postPercentMinSizes","min","postPercentMaxSizes","max","panelSizes"],"mappings":"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","sourcesContent":["import React from 'react';\nexport function getPtg(str) {\n  return Number(str.slice(0, -1)) / 100;\n}\nfunction isPtg(itemSize) {\n  return typeof itemSize === 'string' && itemSize.endsWith('%');\n}\n/**\n * Save the size state.\n * Align the size into flex percentage base.\n */\nexport default function useSizes(items, containerSize) {\n  const propSizes = items.map(item => item.size);\n  const itemsCount = items.length;\n  const mergedContainerSize = containerSize || 0;\n  const ptg2px = ptg => ptg * mergedContainerSize;\n  // We do not need care the size state match the `items` length in `useState`.\n  // It will calculate later.\n  const [innerSizes, setInnerSizes] = React.useState(() => items.map(item => item.defaultSize));\n  const sizes = React.useMemo(() => {\n    var _a;\n    const mergedSizes = [];\n    for (let i = 0; i < itemsCount; i += 1) {\n      mergedSizes[i] = (_a = propSizes[i]) !== null && _a !== void 0 ? _a : innerSizes[i];\n    }\n    return mergedSizes;\n  }, [itemsCount, innerSizes, propSizes]);\n  // Post handle the size. Will do:\n  // 1. Convert all the px into percentage if not empty.\n  // 2. Get rest percentage for exist percentage.\n  // 3. Fill the rest percentage into empty item.\n  const postPercentSizes = React.useMemo(() => {\n    let ptgList = [];\n    let emptyCount = 0;\n    // Fill default percentage\n    for (let i = 0; i < itemsCount; i += 1) {\n      const itemSize = sizes[i];\n      if (isPtg(itemSize)) {\n        ptgList[i] = getPtg(itemSize);\n      } else if (itemSize || itemSize === 0) {\n        const num = Number(itemSize);\n        if (!Number.isNaN(num)) {\n          ptgList[i] = num / mergedContainerSize;\n        }\n      } else {\n        emptyCount += 1;\n        ptgList[i] = undefined;\n      }\n    }\n    const totalPtg = ptgList.reduce((acc, ptg) => acc + (ptg || 0), 0);\n    if (totalPtg > 1 || !emptyCount) {\n      // If total percentage is larger than 1, we will scale it down.\n      const scale = 1 / totalPtg;\n      ptgList = ptgList.map(ptg => ptg === undefined ? 0 : ptg * scale);\n    } else {\n      // If total percentage is smaller than 1, we will fill the rest.\n      const avgRest = (1 - totalPtg) / emptyCount;\n      ptgList = ptgList.map(ptg => ptg === undefined ? avgRest : ptg);\n    }\n    return ptgList;\n  }, [sizes, mergedContainerSize]);\n  const postPxSizes = React.useMemo(() => postPercentSizes.map(ptg2px), [postPercentSizes, mergedContainerSize]);\n  const postPercentMinSizes = React.useMemo(() => items.map(item => {\n    if (isPtg(item.min)) {\n      return getPtg(item.min);\n    }\n    return (item.min || 0) / mergedContainerSize;\n  }), [items, mergedContainerSize]);\n  const postPercentMaxSizes = React.useMemo(() => items.map(item => {\n    if (isPtg(item.max)) {\n      return getPtg(item.max);\n    }\n    return (item.max || mergedContainerSize) / mergedContainerSize;\n  }), [items, mergedContainerSize]);\n  // If ssr, we will use the size from developer config first.\n  const panelSizes = React.useMemo(() => containerSize ? postPxSizes : sizes, [postPxSizes, containerSize]);\n  return [panelSizes, postPxSizes, postPercentSizes, postPercentMinSizes, postPercentMaxSizes, setInnerSizes];\n}"]},"metadata":{},"sourceType":"module"}