{"ast":null,"code":"import _slicedToArray from \"/Users/shamryshiraz/Documents/New/Untitled/Portfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as React from 'react';\nimport { groupKeysMap } from '../../_util/transKeys';\n\nvar useData = function useData(dataSource, rowKey, targetKeys) {\n  var mergedDataSource = React.useMemo(function () {\n    return (dataSource || []).map(function (record) {\n      if (rowKey) {\n        return Object.assign(Object.assign({}, record), {\n          key: rowKey(record)\n        });\n      }\n\n      return record;\n    });\n  }, [dataSource, rowKey]);\n\n  var _React$useMemo = React.useMemo(function () {\n    var _a;\n\n    var leftData = [];\n    var rightData = Array.from({\n      length: (_a = targetKeys === null || targetKeys === void 0 ? void 0 : targetKeys.length) !== null && _a !== void 0 ? _a : 0\n    });\n    var targetKeysMap = groupKeysMap(targetKeys || []);\n    mergedDataSource.forEach(function (record) {\n      // rightData should be ordered by targetKeys\n      // leftData should be ordered by dataSource\n      if (targetKeysMap.has(record.key)) {\n        var idx = targetKeysMap.get(record.key);\n        rightData[idx] = record;\n      } else {\n        leftData.push(record);\n      }\n    });\n    return [leftData, rightData];\n  }, [mergedDataSource, targetKeys]),\n      _React$useMemo2 = _slicedToArray(_React$useMemo, 2),\n      leftDataSource = _React$useMemo2[0],\n      rightDataSource = _React$useMemo2[1];\n\n  return [mergedDataSource, leftDataSource.filter(Boolean), rightDataSource.filter(Boolean)];\n};\n\nexport default useData;","map":{"version":3,"sources":["/Users/shamryshiraz/Documents/New/Untitled/Portfolio/node_modules/antd/es/transfer/hooks/useData.js"],"names":["React","groupKeysMap","useData","dataSource","rowKey","targetKeys","mergedDataSource","useMemo","map","record","Object","assign","key","_a","leftData","rightData","Array","from","length","targetKeysMap","forEach","has","idx","get","push","leftDataSource","rightDataSource","filter","Boolean"],"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,YAAT,QAA6B,uBAA7B;;AACA,IAAMC,OAAO,GAAG,SAAVA,OAAU,CAACC,UAAD,EAAaC,MAAb,EAAqBC,UAArB,EAAoC;AAClD,MAAMC,gBAAgB,GAAGN,KAAK,CAACO,OAAN,CAAc;AAAA,WAAM,CAACJ,UAAU,IAAI,EAAf,EAAmBK,GAAnB,CAAuB,UAAAC,MAAM,EAAI;AAC5E,UAAIL,MAAJ,EAAY;AACV,eAAOM,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBF,MAAlB,CAAd,EAAyC;AAC9CG,UAAAA,GAAG,EAAER,MAAM,CAACK,MAAD;AADmC,SAAzC,CAAP;AAGD;;AACD,aAAOA,MAAP;AACD,KAP4C,CAAN;AAAA,GAAd,EAOrB,CAACN,UAAD,EAAaC,MAAb,CAPqB,CAAzB;;AAQA,uBAA0CJ,KAAK,CAACO,OAAN,CAAc,YAAM;AAC5D,QAAIM,EAAJ;;AACA,QAAMC,QAAQ,GAAG,EAAjB;AACA,QAAMC,SAAS,GAAGC,KAAK,CAACC,IAAN,CAAW;AAC3BC,MAAAA,MAAM,EAAE,CAACL,EAAE,GAAGR,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAACa,MAAzE,MAAqF,IAArF,IAA6FL,EAAE,KAAK,KAAK,CAAzG,GAA6GA,EAA7G,GAAkH;AAD/F,KAAX,CAAlB;AAGA,QAAMM,aAAa,GAAGlB,YAAY,CAACI,UAAU,IAAI,EAAf,CAAlC;AACAC,IAAAA,gBAAgB,CAACc,OAAjB,CAAyB,UAAAX,MAAM,EAAI;AACjC;AACA;AACA,UAAIU,aAAa,CAACE,GAAd,CAAkBZ,MAAM,CAACG,GAAzB,CAAJ,EAAmC;AACjC,YAAMU,GAAG,GAAGH,aAAa,CAACI,GAAd,CAAkBd,MAAM,CAACG,GAAzB,CAAZ;AACAG,QAAAA,SAAS,CAACO,GAAD,CAAT,GAAiBb,MAAjB;AACD,OAHD,MAGO;AACLK,QAAAA,QAAQ,CAACU,IAAT,CAAcf,MAAd;AACD;AACF,KATD;AAUA,WAAO,CAACK,QAAD,EAAWC,SAAX,CAAP;AACD,GAlByC,EAkBvC,CAACT,gBAAD,EAAmBD,UAAnB,CAlBuC,CAA1C;AAAA;AAAA,MAAOoB,cAAP;AAAA,MAAuBC,eAAvB;;AAmBA,SAAO,CAACpB,gBAAD,EAAmBmB,cAAc,CAACE,MAAf,CAAsBC,OAAtB,CAAnB,EAAmDF,eAAe,CAACC,MAAhB,CAAuBC,OAAvB,CAAnD,CAAP;AACD,CA7BD;;AA8BA,eAAe1B,OAAf","sourcesContent":["import * as React from 'react';\nimport { groupKeysMap } from '../../_util/transKeys';\nconst useData = (dataSource, rowKey, targetKeys) => {\n  const mergedDataSource = React.useMemo(() => (dataSource || []).map(record => {\n    if (rowKey) {\n      return Object.assign(Object.assign({}, record), {\n        key: rowKey(record)\n      });\n    }\n    return record;\n  }), [dataSource, rowKey]);\n  const [leftDataSource, rightDataSource] = React.useMemo(() => {\n    var _a;\n    const leftData = [];\n    const rightData = Array.from({\n      length: (_a = targetKeys === null || targetKeys === void 0 ? void 0 : targetKeys.length) !== null && _a !== void 0 ? _a : 0\n    });\n    const targetKeysMap = groupKeysMap(targetKeys || []);\n    mergedDataSource.forEach(record => {\n      // rightData should be ordered by targetKeys\n      // leftData should be ordered by dataSource\n      if (targetKeysMap.has(record.key)) {\n        const idx = targetKeysMap.get(record.key);\n        rightData[idx] = record;\n      } else {\n        leftData.push(record);\n      }\n    });\n    return [leftData, rightData];\n  }, [mergedDataSource, targetKeys]);\n  return [mergedDataSource, leftDataSource.filter(Boolean), rightDataSource.filter(Boolean)];\n};\nexport default useData;"]},"metadata":{},"sourceType":"module"}