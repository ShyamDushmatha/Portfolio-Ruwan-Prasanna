{"ast":null,"code":"\"use client\";\n\nimport _slicedToArray from \"/Users/shamryshiraz/Documents/New/Untitled/Portfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport React, { useEffect } from 'react';\nimport { useMutateObserver } from '@rc-component/mutate-observer';\nimport classNames from 'classnames';\nimport useEvent from \"rc-util/es/hooks/useEvent\";\nimport toList from '../_util/toList';\nimport { useToken } from '../theme/internal';\nimport WatermarkContext from './context';\nimport useClips, { FontGap } from './useClips';\nimport useRafDebounce from './useRafDebounce';\nimport useSingletonCache from './useSingletonCache';\nimport useWatermark from './useWatermark';\nimport { getPixelRatio, reRendering } from './utils';\n/**\n * Only return `next` when size changed.\n * This is only used for elements compare, not a shallow equal!\n */\n\nfunction getSizeDiff(prev, next) {\n  return prev.size === next.size ? prev : next;\n}\n\nvar DEFAULT_GAP_X = 100;\nvar DEFAULT_GAP_Y = 100;\nvar fixedStyle = {\n  position: 'relative',\n  overflow: 'hidden'\n};\n\nvar Watermark = function Watermark(props) {\n  var _a, _b;\n\n  var _props$zIndex = props.zIndex,\n      zIndex = _props$zIndex === void 0 ? 9 : _props$zIndex,\n      _props$rotate = props.rotate,\n      rotate = _props$rotate === void 0 ? -22 : _props$rotate,\n      width = props.width,\n      height = props.height,\n      image = props.image,\n      content = props.content,\n      _props$font = props.font,\n      font = _props$font === void 0 ? {} : _props$font,\n      style = props.style,\n      className = props.className,\n      rootClassName = props.rootClassName,\n      _props$gap = props.gap,\n      gap = _props$gap === void 0 ? [DEFAULT_GAP_X, DEFAULT_GAP_Y] : _props$gap,\n      offset = props.offset,\n      children = props.children,\n      _props$inherit = props.inherit,\n      inherit = _props$inherit === void 0 ? true : _props$inherit;\n  var mergedStyle = Object.assign(Object.assign({}, fixedStyle), style);\n\n  var _useToken = useToken(),\n      _useToken2 = _slicedToArray(_useToken, 2),\n      token = _useToken2[1];\n\n  var _font$color = font.color,\n      color = _font$color === void 0 ? token.colorFill : _font$color,\n      _font$fontSize = font.fontSize,\n      fontSize = _font$fontSize === void 0 ? token.fontSizeLG : _font$fontSize,\n      _font$fontWeight = font.fontWeight,\n      fontWeight = _font$fontWeight === void 0 ? 'normal' : _font$fontWeight,\n      _font$fontStyle = font.fontStyle,\n      fontStyle = _font$fontStyle === void 0 ? 'normal' : _font$fontStyle,\n      _font$fontFamily = font.fontFamily,\n      fontFamily = _font$fontFamily === void 0 ? 'sans-serif' : _font$fontFamily,\n      _font$textAlign = font.textAlign,\n      textAlign = _font$textAlign === void 0 ? 'center' : _font$textAlign;\n\n  var _gap = _slicedToArray(gap, 2),\n      _gap$ = _gap[0],\n      gapX = _gap$ === void 0 ? DEFAULT_GAP_X : _gap$,\n      _gap$2 = _gap[1],\n      gapY = _gap$2 === void 0 ? DEFAULT_GAP_Y : _gap$2;\n\n  var gapXCenter = gapX / 2;\n  var gapYCenter = gapY / 2;\n  var offsetLeft = (_a = offset === null || offset === void 0 ? void 0 : offset[0]) !== null && _a !== void 0 ? _a : gapXCenter;\n  var offsetTop = (_b = offset === null || offset === void 0 ? void 0 : offset[1]) !== null && _b !== void 0 ? _b : gapYCenter;\n  var markStyle = React.useMemo(function () {\n    var mergedMarkStyle = {\n      zIndex: zIndex,\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      backgroundRepeat: 'repeat'\n    };\n    /** Calculate the style of the offset */\n\n    var positionLeft = offsetLeft - gapXCenter;\n    var positionTop = offsetTop - gapYCenter;\n\n    if (positionLeft > 0) {\n      mergedMarkStyle.left = \"\".concat(positionLeft, \"px\");\n      mergedMarkStyle.width = \"calc(100% - \".concat(positionLeft, \"px)\");\n      positionLeft = 0;\n    }\n\n    if (positionTop > 0) {\n      mergedMarkStyle.top = \"\".concat(positionTop, \"px\");\n      mergedMarkStyle.height = \"calc(100% - \".concat(positionTop, \"px)\");\n      positionTop = 0;\n    }\n\n    mergedMarkStyle.backgroundPosition = \"\".concat(positionLeft, \"px \").concat(positionTop, \"px\");\n    return mergedMarkStyle;\n  }, [zIndex, offsetLeft, gapXCenter, offsetTop, gapYCenter]);\n\n  var _React$useState = React.useState(),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      container = _React$useState2[0],\n      setContainer = _React$useState2[1]; // Used for nest case like Modal, Drawer\n\n\n  var _React$useState3 = React.useState(function () {\n    return new Set();\n  }),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      subElements = _React$useState4[0],\n      setSubElements = _React$useState4[1]; // Nest elements should also support watermark\n\n\n  var targetElements = React.useMemo(function () {\n    var list = container ? [container] : [];\n    return [].concat(list, _toConsumableArray(Array.from(subElements)));\n  }, [container, subElements]); // ============================ Content =============================\n\n  /**\n   * Get the width and height of the watermark. The default values are as follows\n   * Image: [120, 64]; Content: It's calculated by content;\n   */\n\n  var getMarkSize = function getMarkSize(ctx) {\n    var defaultWidth = 120;\n    var defaultHeight = 64;\n\n    if (!image && ctx.measureText) {\n      ctx.font = \"\".concat(Number(fontSize), \"px \").concat(fontFamily);\n      var contents = toList(content);\n      var sizes = contents.map(function (item) {\n        var metrics = ctx.measureText(item);\n        return [metrics.width, metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent];\n      });\n      defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map(function (size) {\n        return size[0];\n      }))));\n      defaultHeight = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map(function (size) {\n        return size[1];\n      })))) * contents.length + (contents.length - 1) * FontGap;\n    }\n\n    return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n  };\n\n  var getClips = useClips();\n  var getClipsCache = useSingletonCache();\n\n  var _React$useState5 = React.useState(null),\n      _React$useState6 = _slicedToArray(_React$useState5, 2),\n      watermarkInfo = _React$useState6[0],\n      setWatermarkInfo = _React$useState6[1]; // Generate new Watermark content\n\n\n  var renderWatermark = function renderWatermark() {\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n\n    if (ctx) {\n      var ratio = getPixelRatio();\n\n      var _getMarkSize = getMarkSize(ctx),\n          _getMarkSize2 = _slicedToArray(_getMarkSize, 2),\n          markWidth = _getMarkSize2[0],\n          markHeight = _getMarkSize2[1];\n\n      var drawCanvas = function drawCanvas(drawContent) {\n        var params = [drawContent || '', rotate, ratio, markWidth, markHeight, {\n          color: color,\n          fontSize: fontSize,\n          fontStyle: fontStyle,\n          fontWeight: fontWeight,\n          fontFamily: fontFamily,\n          textAlign: textAlign\n        }, gapX, gapY];\n\n        var _getClipsCache = getClipsCache(params, function () {\n          return getClips.apply(void 0, params);\n        }),\n            _getClipsCache2 = _slicedToArray(_getClipsCache, 2),\n            nextClips = _getClipsCache2[0],\n            clipWidth = _getClipsCache2[1];\n\n        setWatermarkInfo([nextClips, clipWidth]);\n      };\n\n      if (image) {\n        var img = new Image();\n\n        img.onload = function () {\n          drawCanvas(img);\n        };\n\n        img.onerror = function () {\n          drawCanvas(content);\n        };\n\n        img.crossOrigin = 'anonymous';\n        img.referrerPolicy = 'no-referrer';\n        img.src = image;\n      } else {\n        drawCanvas(content);\n      }\n    }\n  };\n\n  var syncWatermark = useRafDebounce(renderWatermark); // ============================= Effect =============================\n  // Append watermark to the container\n\n  var _useWatermark = useWatermark(markStyle),\n      _useWatermark2 = _slicedToArray(_useWatermark, 3),\n      appendWatermark = _useWatermark2[0],\n      removeWatermark = _useWatermark2[1],\n      isWatermarkEle = _useWatermark2[2];\n\n  useEffect(function () {\n    if (watermarkInfo) {\n      targetElements.forEach(function (holder) {\n        appendWatermark(watermarkInfo[0], watermarkInfo[1], holder);\n      });\n    }\n  }, [watermarkInfo, targetElements]); // ============================ Observe =============================\n\n  var onMutate = useEvent(function (mutations) {\n    mutations.forEach(function (mutation) {\n      if (reRendering(mutation, isWatermarkEle)) {\n        syncWatermark();\n      } else if (mutation.target === container && mutation.attributeName === 'style') {\n        // We've only force container not modify.\n        // Not consider nest case.\n        var keyStyles = Object.keys(fixedStyle);\n\n        for (var i = 0; i < keyStyles.length; i += 1) {\n          var key = keyStyles[i];\n          var oriValue = mergedStyle[key];\n          var currentValue = container.style[key];\n\n          if (oriValue && oriValue !== currentValue) {\n            container.style[key] = oriValue;\n          }\n        }\n      }\n    });\n  });\n  useMutateObserver(targetElements, onMutate);\n  useEffect(syncWatermark, [rotate, zIndex, width, height, image, content, color, fontSize, fontWeight, fontStyle, fontFamily, textAlign, gapX, gapY, offsetLeft, offsetTop]); // ============================ Context =============================\n\n  var watermarkContext = React.useMemo(function () {\n    return {\n      add: function add(ele) {\n        setSubElements(function (prev) {\n          var clone = new Set(prev);\n          clone.add(ele);\n          return getSizeDiff(prev, clone);\n        });\n      },\n      remove: function remove(ele) {\n        removeWatermark(ele);\n        setSubElements(function (prev) {\n          var clone = new Set(prev);\n          clone.delete(ele);\n          return getSizeDiff(prev, clone);\n        });\n      }\n    };\n  }, []); // ============================= Render =============================\n\n  var childNode = inherit ? /*#__PURE__*/React.createElement(WatermarkContext.Provider, {\n    value: watermarkContext\n  }, children) : children;\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: setContainer,\n    className: classNames(className, rootClassName),\n    style: mergedStyle\n  }, childNode);\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  Watermark.displayName = 'Watermark';\n}\n\nexport default Watermark;","map":{"version":3,"sources":["/Users/shamryshiraz/Documents/New/Untitled/Portfolio/node_modules/antd/es/watermark/index.js"],"names":["_toConsumableArray","React","useEffect","useMutateObserver","classNames","useEvent","toList","useToken","WatermarkContext","useClips","FontGap","useRafDebounce","useSingletonCache","useWatermark","getPixelRatio","reRendering","getSizeDiff","prev","next","size","DEFAULT_GAP_X","DEFAULT_GAP_Y","fixedStyle","position","overflow","Watermark","props","_a","_b","zIndex","rotate","width","height","image","content","font","style","className","rootClassName","gap","offset","children","inherit","mergedStyle","Object","assign","token","color","colorFill","fontSize","fontSizeLG","fontWeight","fontStyle","fontFamily","textAlign","gapX","gapY","gapXCenter","gapYCenter","offsetLeft","offsetTop","markStyle","useMemo","mergedMarkStyle","left","top","pointerEvents","backgroundRepeat","positionLeft","positionTop","backgroundPosition","useState","container","setContainer","Set","subElements","setSubElements","targetElements","list","concat","Array","from","getMarkSize","ctx","defaultWidth","defaultHeight","measureText","Number","contents","sizes","map","item","metrics","fontBoundingBoxAscent","fontBoundingBoxDescent","Math","ceil","max","apply","length","getClips","getClipsCache","watermarkInfo","setWatermarkInfo","renderWatermark","canvas","document","createElement","getContext","ratio","markWidth","markHeight","drawCanvas","drawContent","params","nextClips","clipWidth","img","Image","onload","onerror","crossOrigin","referrerPolicy","src","syncWatermark","appendWatermark","removeWatermark","isWatermarkEle","forEach","holder","onMutate","mutations","mutation","target","attributeName","keyStyles","keys","i","key","oriValue","currentValue","watermarkContext","add","ele","clone","remove","delete","childNode","Provider","value","ref","process","env","NODE_ENV","displayName"],"mappings":"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","sourcesContent":["\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport React, { useEffect } from 'react';\nimport { useMutateObserver } from '@rc-component/mutate-observer';\nimport classNames from 'classnames';\nimport useEvent from \"rc-util/es/hooks/useEvent\";\nimport toList from '../_util/toList';\nimport { useToken } from '../theme/internal';\nimport WatermarkContext from './context';\nimport useClips, { FontGap } from './useClips';\nimport useRafDebounce from './useRafDebounce';\nimport useSingletonCache from './useSingletonCache';\nimport useWatermark from './useWatermark';\nimport { getPixelRatio, reRendering } from './utils';\n/**\n * Only return `next` when size changed.\n * This is only used for elements compare, not a shallow equal!\n */\nfunction getSizeDiff(prev, next) {\n  return prev.size === next.size ? prev : next;\n}\nconst DEFAULT_GAP_X = 100;\nconst DEFAULT_GAP_Y = 100;\nconst fixedStyle = {\n  position: 'relative',\n  overflow: 'hidden'\n};\nconst Watermark = props => {\n  var _a, _b;\n  const {\n    /**\n     * The antd content layer zIndex is basically below 10\n     * https://github.com/ant-design/ant-design/blob/6192403b2ce517c017f9e58a32d58774921c10cd/components/style/themes/default.less#L335\n     */\n    zIndex = 9,\n    rotate = -22,\n    width,\n    height,\n    image,\n    content,\n    font = {},\n    style,\n    className,\n    rootClassName,\n    gap = [DEFAULT_GAP_X, DEFAULT_GAP_Y],\n    offset,\n    children,\n    inherit = true\n  } = props;\n  const mergedStyle = Object.assign(Object.assign({}, fixedStyle), style);\n  const [, token] = useToken();\n  const {\n    color = token.colorFill,\n    fontSize = token.fontSizeLG,\n    fontWeight = 'normal',\n    fontStyle = 'normal',\n    fontFamily = 'sans-serif',\n    textAlign = 'center'\n  } = font;\n  const [gapX = DEFAULT_GAP_X, gapY = DEFAULT_GAP_Y] = gap;\n  const gapXCenter = gapX / 2;\n  const gapYCenter = gapY / 2;\n  const offsetLeft = (_a = offset === null || offset === void 0 ? void 0 : offset[0]) !== null && _a !== void 0 ? _a : gapXCenter;\n  const offsetTop = (_b = offset === null || offset === void 0 ? void 0 : offset[1]) !== null && _b !== void 0 ? _b : gapYCenter;\n  const markStyle = React.useMemo(() => {\n    const mergedMarkStyle = {\n      zIndex,\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      backgroundRepeat: 'repeat'\n    };\n    /** Calculate the style of the offset */\n    let positionLeft = offsetLeft - gapXCenter;\n    let positionTop = offsetTop - gapYCenter;\n    if (positionLeft > 0) {\n      mergedMarkStyle.left = `${positionLeft}px`;\n      mergedMarkStyle.width = `calc(100% - ${positionLeft}px)`;\n      positionLeft = 0;\n    }\n    if (positionTop > 0) {\n      mergedMarkStyle.top = `${positionTop}px`;\n      mergedMarkStyle.height = `calc(100% - ${positionTop}px)`;\n      positionTop = 0;\n    }\n    mergedMarkStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n    return mergedMarkStyle;\n  }, [zIndex, offsetLeft, gapXCenter, offsetTop, gapYCenter]);\n  const [container, setContainer] = React.useState();\n  // Used for nest case like Modal, Drawer\n  const [subElements, setSubElements] = React.useState(() => new Set());\n  // Nest elements should also support watermark\n  const targetElements = React.useMemo(() => {\n    const list = container ? [container] : [];\n    return [].concat(list, _toConsumableArray(Array.from(subElements)));\n  }, [container, subElements]);\n  // ============================ Content =============================\n  /**\n   * Get the width and height of the watermark. The default values are as follows\n   * Image: [120, 64]; Content: It's calculated by content;\n   */\n  const getMarkSize = ctx => {\n    let defaultWidth = 120;\n    let defaultHeight = 64;\n    if (!image && ctx.measureText) {\n      ctx.font = `${Number(fontSize)}px ${fontFamily}`;\n      const contents = toList(content);\n      const sizes = contents.map(item => {\n        const metrics = ctx.measureText(item);\n        return [metrics.width, metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent];\n      });\n      defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map(size => size[0]))));\n      defaultHeight = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map(size => size[1])))) * contents.length + (contents.length - 1) * FontGap;\n    }\n    return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n  };\n  const getClips = useClips();\n  const getClipsCache = useSingletonCache();\n  const [watermarkInfo, setWatermarkInfo] = React.useState(null);\n  // Generate new Watermark content\n  const renderWatermark = () => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      const ratio = getPixelRatio();\n      const [markWidth, markHeight] = getMarkSize(ctx);\n      const drawCanvas = drawContent => {\n        const params = [drawContent || '', rotate, ratio, markWidth, markHeight, {\n          color,\n          fontSize,\n          fontStyle,\n          fontWeight,\n          fontFamily,\n          textAlign\n        }, gapX, gapY];\n        const [nextClips, clipWidth] = getClipsCache(params, () => getClips.apply(void 0, params));\n        setWatermarkInfo([nextClips, clipWidth]);\n      };\n      if (image) {\n        const img = new Image();\n        img.onload = () => {\n          drawCanvas(img);\n        };\n        img.onerror = () => {\n          drawCanvas(content);\n        };\n        img.crossOrigin = 'anonymous';\n        img.referrerPolicy = 'no-referrer';\n        img.src = image;\n      } else {\n        drawCanvas(content);\n      }\n    }\n  };\n  const syncWatermark = useRafDebounce(renderWatermark);\n  // ============================= Effect =============================\n  // Append watermark to the container\n  const [appendWatermark, removeWatermark, isWatermarkEle] = useWatermark(markStyle);\n  useEffect(() => {\n    if (watermarkInfo) {\n      targetElements.forEach(holder => {\n        appendWatermark(watermarkInfo[0], watermarkInfo[1], holder);\n      });\n    }\n  }, [watermarkInfo, targetElements]);\n  // ============================ Observe =============================\n  const onMutate = useEvent(mutations => {\n    mutations.forEach(mutation => {\n      if (reRendering(mutation, isWatermarkEle)) {\n        syncWatermark();\n      } else if (mutation.target === container && mutation.attributeName === 'style') {\n        // We've only force container not modify.\n        // Not consider nest case.\n        const keyStyles = Object.keys(fixedStyle);\n        for (let i = 0; i < keyStyles.length; i += 1) {\n          const key = keyStyles[i];\n          const oriValue = mergedStyle[key];\n          const currentValue = container.style[key];\n          if (oriValue && oriValue !== currentValue) {\n            container.style[key] = oriValue;\n          }\n        }\n      }\n    });\n  });\n  useMutateObserver(targetElements, onMutate);\n  useEffect(syncWatermark, [rotate, zIndex, width, height, image, content, color, fontSize, fontWeight, fontStyle, fontFamily, textAlign, gapX, gapY, offsetLeft, offsetTop]);\n  // ============================ Context =============================\n  const watermarkContext = React.useMemo(() => ({\n    add: ele => {\n      setSubElements(prev => {\n        const clone = new Set(prev);\n        clone.add(ele);\n        return getSizeDiff(prev, clone);\n      });\n    },\n    remove: ele => {\n      removeWatermark(ele);\n      setSubElements(prev => {\n        const clone = new Set(prev);\n        clone.delete(ele);\n        return getSizeDiff(prev, clone);\n      });\n    }\n  }), []);\n  // ============================= Render =============================\n  const childNode = inherit ? (/*#__PURE__*/React.createElement(WatermarkContext.Provider, {\n    value: watermarkContext\n  }, children)) : children;\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: setContainer,\n    className: classNames(className, rootClassName),\n    style: mergedStyle\n  }, childNode);\n};\nif (process.env.NODE_ENV !== 'production') {\n  Watermark.displayName = 'Watermark';\n}\nexport default Watermark;"]},"metadata":{},"sourceType":"module"}